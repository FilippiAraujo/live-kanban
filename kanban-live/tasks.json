{
  "milestones": [
    {
      "id": "m1",
      "titulo": "MVP",
      "descricao": "Funcionalidades essenciais do Kanban",
      "cor": "#3b82f6"
    },
    {
      "id": "m2",
      "titulo": "Melhorias UX",
      "descricao": "Interface e experiência do usuário",
      "cor": "#8b5cf6"
    },
    {
      "id": "m3",
      "titulo": "Integração IA",
      "descricao": "Funcionalidades com agentes e LLMs",
      "cor": "#10b981"
    },
    {
      "id": "m4",
      "titulo": "Futuro",
      "descricao": "Funcionalidades futuras e experimentais",
      "cor": "#f59e0b"
    },
    {
      "id": "m5596",
      "titulo": "Integração Notion",
      "cor": "#53d08f"
    },
    {
      "id": "m6021",
      "titulo": "Melhorias Tasks",
      "cor": "#98b4e1"
    },
    {
      "id": "m8738",
      "titulo": "Timeline Ações Tasks",
      "cor": "#d963c9"
    },
    {
      "id": "m2972",
      "titulo": "Git",
      "cor": "#eaf73b"
    },
    {
      "id": "m1101",
      "titulo": "Milestones",
      "cor": "#14161a"
    },
    {
      "id": "m3875",
      "titulo": "Bugs",
      "cor": "#46494e"
    },
    {
      "id": "m0916",
      "titulo": "Open Source",
      "cor": "#3b82f6"
    }
  ],
  "backlog": [
    {
      "id": "t7256",
      "descricao": "Esconder botão “Setup” quando o projeto já tem a estrutura kanban-live (validação via API).",
      "detalhes": "O que precisa ser feito:\n\n- Reproduzir o bug localmente e anotar passos/console logs onde o botão `Setup` aparece indevidamente.\n- Implementar uma função isProjectSetup(path: string): Promise<boolean> em client/src/lib/api.ts que chama GET /api/board?path=... e valida a estrutura retornada (presença de `milestones` como array e ao menos as colunas padrão: backlog/todo/doing/done). A função deve:\n  - Retornar true apenas se a resposta for 200 JSON válida com `milestones` Array e colunas (mesmo vazias).\n  - Retornar false quando o backend devolver 404, erro de rede, ou JSON inválido.\n  - Usar AbortController para permitir cancelamento de chamadas concorrentes.\n  - Não lançar para erros esperados; resolver em false e logar detalhes (console.error) para debug.\n\n- Criar um hook reutilizável (ex: client/src/hooks/useProjectSetup.ts) que exponha o estado isSetup, loading e error, faça debounce do input de path (≈300ms) e cancele requisições antigas.\n\n- Alterar client/src/components/Header.tsx para usar o hook / isProjectSetup e ocultar o botão `Setup` quando isSetup === true; garantir que a checagem execute ao mudar o input de path e ao carregar boardData do BoardContext (evitar chamadas duplicadas quando BoardContext já tem os dados).\n\n- Se for necessário, adicionar/expôr um estado derivado em client/src/contexts/BoardContext.tsx (ex: boardData?.isSetup) para evitar chamadas redundantes — preferir derivar isSetup da própria boardData quando disponível.\n\nArquivos a modificar (prováveis):\n\n- client/src/lib/api.ts            // adicionar isProjectSetup(path): Promise<boolean>, usar fetch/cliente HTTP existente e AbortController\n- client/src/hooks/useProjectSetup.ts // novo hook reativo (debounce + cancel + integração com BoardContext)\n- client/src/components/Header.tsx  // lógica de exibição do botão Setup, usar hook/isProjectSetup\n- client/src/contexts/BoardContext.tsx  // (opcional) expor boardData para evitar chamadas duplicadas\n- kanban-live/tasks.json           // leitura/validação manual durante reprodução (NUNCA editar)\n\nObservações / Requisitos técnicos:\n\n- Validação da resposta: considerar projeto como \"setup concluído\" quando:\n  1) GET /api/board?path=... retorna 200 com JSON;\n  2) body.milestones é Array (mesmo vazio é aceitável, preferencialmente >= 0 mas recomendamos ao menos [] present);\n  3) existe pelo menos as propriedades backlog/todo/doing/done (arrays) no body (podem estar vazias).\n- Em caso de 404, erro de parsing ou resposta inesperada, tratar como NÃO configurado (retornar false).\n- Performance: a checagem deve ser executada on-demand — ao mudar o path ou quando BoardContext carrega novos dados. Implementar debounce (~300ms) no input do path e usar AbortController para cancelar requisições antigas.\n- Integração com padrões do projeto:\n  - Importar tipos com import type { Task, Milestone } from '@/types.js' quando necessário.\n  - Usar o cliente HTTP existente em client/src/lib/api.ts (reaproveitar utilidades) — não adicionar dependências.\n  - Para feedback de erro, usar sonner (toasts) já presente no projeto.\n  - Não modificar componentes gerados pelo shadcn/ui manualmente.\n\n⚠️ Warnings:\n- ⚠️ NÃO editar kanban-live/tasks.json para \"marcar\" projeto como configurado — somente leitura/validação.\n- ⚠️ Evite chamadas duplicadas: se BoardContext já carregou boardData use-o para decidir isSetup sem nova requisição.\n- ⚠️ Preserve performance e UX: debounce e cancelamento são obrigatórios para evitar flood de requests ao digitar o path.\n- ⚠️ Logar detalhes de erro em console.error, mas mostrar mensagens amigáveis via toast (sonner) para o usuário.\n- ⚠️ Não adicionar novas dependências; implemente com APIs e utilitários existentes.\n",
      "milestone": "m2",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:45:04-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T23:48:17-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:24:38-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:30:05-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:43:42.574-03:00"
        }
      ],
      "todos": [
        {
          "id": "td54356419",
          "texto": "Reproduzir e documentar o bug: abrir um projeto que já tem kanban-live e confirmar quando o botão Setup aparece; salvar passos e console logs.",
          "concluido": false
        },
        {
          "id": "td54359013",
          "texto": "Implementar isProjectSetup(path: string): Promise<boolean> em client/src/lib/api.ts que chama GET /api/board?path=...; validar presença de milestones e colunas; usar AbortController e retornar boolean.",
          "concluido": false
        },
        {
          "id": "td54354011",
          "texto": "Criar hook client/src/hooks/useProjectSetup.ts que faz debounce do path (≈300ms), gerencia cancelamento de requests, expõe { isSetup, loading, error } e reutiliza BoardContext quando disponível.",
          "concluido": false
        },
        {
          "id": "td54355737",
          "texto": "Modificar client/src/components/Header.tsx para usar o hook/isProjectSetup e ocultar o botão Setup quando isSetup === true; garantir atualização reativa ao mudar o input de path.",
          "concluido": false
        },
        {
          "id": "td54353054",
          "texto": "Sincronizar com client/src/contexts/BoardContext.tsx: quando boardData estiver presente, derivar isSetup do boardData para evitar chamada adicional; atualizar contexto se necessário.",
          "concluido": false
        },
        {
          "id": "td54351150",
          "texto": "Adicionar tratamento de erros: console.error para detalhes e exibir toast (sonner) em falhas de checagem; garantir UX consistente em casos intermitentes de rede.",
          "concluido": false
        },
        {
          "id": "td54353053",
          "texto": "Testes manuais finais: validar caminhos com setup (kanban-live/tasks.json com milestones) → botão oculto; caminhos novos/ inválidos → botão visível; testar troca rápida de path e cancelamento de chamadas.",
          "concluido": false
        }
      ],
      "dataInicio": "2025-12-05T00:24:38-03:00"
    },
    {
      "id": "t7391",
      "descricao": "ao copiar um projeto (o path), idealmente, a gente copia junto, a explicação do projeto, que vai ta la no objetivo e status, algo assim",
      "milestone": "m2",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:44:59-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:39:44.379-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T03:39:46.018-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:43:43.983-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:43:43-03:00"
        }
      ]
    },
    {
      "id": "t4924",
      "descricao": "\"Pesquisar e documentar as melhores práticas para integrar o Notion ao sistema Kanban, incluindo ferramentas e métodos de sincronização.\"",
      "detalhes": "A ideia é que possamos integrar o notion ao kanban, onde ele fica syncado com o seu notion, pra você poder ver as tasks la e etc..",
      "milestone": "m5596",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:45:07-03:00"
        }
      ]
    },
    {
      "id": "t1005",
      "descricao": "o \"objetivos e status\" precisa ser o coração do projeto, e, sempre que tiver uma alteração, ou uma task nova, ele precisa ser atualizado, idealmente, temos um agente olhando para as alterações futuras pos o dia daquele documento, que pega o que foi alterado, e atualiza o \"obejtivo e status\" ou algo similar, em uma linguagem que uma LLM entenda - pensa em como fazer isso",
      "milestone": "m3",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:47:54-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:30:05-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:38:33-03:00"
        }
      ],
      "dataFinalizacao": "2025-12-05T00:30:04-03:00",
      "dataInicio": "2025-12-05T00:38:32-03:00"
    },
    {
      "id": "t2118",
      "descricao": "Confirmar com o usuário antes de executar sugestão da IA ao enriquecer uma task",
      "milestone": "m3",
      "dataCriacao": "2025-12-04T01:34:32-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T01:34:32-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:38:20-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:38:27-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:38:29-03:00"
        }
      ],
      "detalhes": "O que precisa ser feito:\n\n- Ao clicar no botão/ícone de \"IA\" de uma task, NÃO executar automaticamente a alteração. Em vez disso, abrir um modal de confirmação que:\n  - solicita permissão para usar a IA;\n  - mostra a sugestão gerada (preview) comparada com o conteúdo atual (detalhes/descricao);\n  - oferece opções: Substituir, Mesclar/Anexar ou Cancelar.\n- Se o usuário confirmar \"Substituir\", atualizar a task (campo descricao/detalhes/todos conforme a opção) e salvar via API existente (/api/board/tasks ou usando o contexto do Board). Se escolher \"Mesclar/Anexar\", aplicar as mudanças de forma não-destrutiva (preservar texto atual e adicionar sugestão). Sempre registrar nos detalhes/resultado quais alterações foram aplicadas.\n\nArquivos a modificar (sugestão):\n\n- client/src/components/TaskCard.tsx — alterar handler do botão IA para abrir o modal em vez de chamar a IA diretamente.\n- client/src/components/AIEnhanceConfirmDialog.tsx — novo componente (usar shadcn/ui Dialog) que exibe preview, diferenças básicas e botões de ação.\n- client/src/lib/api.ts — adicionar função getEnhancementSuggestion(task: Task): Promise<{ suggestion: string }> que chama /api/agents/enhance-task (sem salvar automaticamente).\n- client/src/contexts/BoardContext.tsx — (opcional) adicionar helper applyEnhancement(taskId, updates) para aplicar e persistir mudanças via updateTasks / API.\n- kanban-live/tasks.json — (resultado das ações do usuário quando confirmar) será modificado pelo fluxo normal de salvar.\n\nObservações / Regras técnicas:\n\n- Usar o componente Dialog do shadcn/ui (não criar componentes shadcn manualmente via copy-paste; se necessário rodar: npx shadcn@latest add dialog).\n- Mostrar preview antes de qualquer alteração. A chamada ao backend que gera a sugestão deve ser utilizada apenas para obter o conteúdo (preview). A aplicação do conteúdo só ocorre após confirmação explícita do usuário.\n- Ao aplicar substituição, documentar em task.detalhes ou task.resultado quais trechos foram alterados e quais arquivos ou campos foram impactados (seguir padrão de \"detalhes\" do projeto).\n- ⚠️ Preservar campos imutáveis e metadados: não alterar id, timeline, dataCriacao; ao mover colunas, respeitar regras de dataInicio/dataFinalizacao.\n- ⚠️ Validar JSON antes de salvar e usar as funções de persistência existentes (BoardContext / client/src/lib/api.ts) para evitar corruptelas no tasks.json.\n- ✅ Usar sonner/toast para feedback (ex: \"Sugestão gerada\", \"Alteração aplicada\", \"Operação cancelada\").\n\nPontos de atenção (⚠️):\n\n- ⚠️ Não transformar a chamada da IA em ação automática (bug atual). A UX precisa deixar claro que a IA sugere — a decisão final é do usuário.\n- ⚠️ Evitar sobrescrever campos adicionais sem confirmação (ex: todos, resultado). Oferecer opção explícita de preservar/mesclar to-dos.\n- ⚠️ Se for necessário adicionar um componente do shadcn/ui que ainda não exista, use o CLI (npx shadcn@latest add ...) e não copie manualmente a pasta ui/.\n",
      "todos": [
        {
          "id": "td57342027",
          "texto": "Adicionar em client/src/lib/api.ts função getEnhancementSuggestion(task) que chama /api/agents/enhance-task e retorna apenas o preview (não salva).",
          "concluido": false
        },
        {
          "id": "td57342040",
          "texto": "Criar client/src/components/AIEnhanceConfirmDialog.tsx usando shadcn/ui Dialog: mostra loading → preview da sugestão → botões Substituir / Mesclar / Cancelar.",
          "concluido": false
        },
        {
          "id": "td57341349",
          "texto": "Modificar client/src/components/TaskCard.tsx: trocar chamada direta da IA pelo fluxo que abre o dialog e passa a task; bloquear drag/edição enquanto dialog aberto.",
          "concluido": false
        },
        {
          "id": "td57342439",
          "texto": "Implementar aplicação das mudanças: no BoardContext (ou TaskCard) chamar updateTasks/save via client/src/lib/api.ts quando usuário confirmar; registrar alteração em detalhes/resultado.",
          "concluido": false
        },
        {
          "id": "td57348817",
          "texto": "Adicionar toasts (sonner) e testes manuais: testar fluxo Preview → Substituir (ver tasks.json) / Mesclar (preservar texto e to-dos) / Cancelar; validar JSON final.",
          "concluido": false
        }
      ]
    },
    {
      "id": "t6555",
      "descricao": "Implementar rastreabilidade entre commits Git e tarefas: vincular automaticamente/manualmente ID da task nas mensagens de commit (via hooks/webhooks), exibir histórico de commits na interface da task e suportar links bidirecionais.",
      "detalhes": "Regra: Todo commit deve começar com o ID: git commit -m \"[t1001] Adiciona modal de detalhes\".\n\nFeature no Live Kanban: No modal de detalhes da Task (que você já implementou), adicione um campo ou uma lista automática de \"Commits Vinculados\" (pode ser manual no começo ou lendo o log do git local via Node).\n\nPor que ajuda: Quando você se perguntar \"O que eu fiz nessa task?\", o código estará linkado diretamente a ela.\n\nObjetivo: Saber qual código resolveu a Task 1001.\n\nComo: Você coloca [t1001] na mensagem do commit.\n\nResultado: Se der bug na task 1001, você sabe exatamente quais arquivos olhar. Isso não atualiza o contexto do projeto, só organiza o histórico.",
      "milestone": "m1",
      "timeline": [
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T01:04:17-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T01:04:28-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T23:17:33-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:43:19.188-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:43:19-03:00"
        }
      ],
      "dataInicio": "2025-12-04T01:04:17-03:00"
    },
    {
      "id": "t4764",
      "descricao": "Modularizar Backend!",
      "milestone": "m1",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:45:03-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:43:07.756-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:43:07-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T20:30:47.416-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T20:31:05.509-03:00"
        }
      ]
    },
    {
      "id": "t1008",
      "descricao": "Adicionar view 'Patterns' com suporte full-stack: arquivo kanban-live/patterns.md + backend (GET/POST) + client API + BoardData types + UI (PatternsView) + polling/Context + disponibilizar para agentes (opcional).",
      "milestone": "m4",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:44:25-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:43:50.443-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:43:50-03:00"
        }
      ],
      "detalhes": "Contexto resumido\n- O projeto já carrega llmGuide e projetoContext via API e expõe no BoardData (client/src/types.ts -> BoardData).\n- Padrões a seguir: componentes UI em client/src/components, reutilizar Card, MarkdownViewer e CopyButton (já usados em App.tsx). Polling de mudanças é gerenciado em BoardContext.tsx (2s) e compara campos específicos para decidir atualizar.\n\nArquivos Relacionados (onde mexer)\n- backend/server.js — adicionar leitura/escrita de kanban-live/patterns.md e expor rota POST /api/board/patterns; incluir patterns no payload de GET /api/board (mesmo comportamento de llmGuide/projetoContext).\n- kanban-live/patterns.md — novo arquivo com conteúdo inicial LTS/Patterns.\n- client/src/types.ts — adicionar patterns: string no BoardData e 'patterns' em ViewType.\n- client/src/lib/api.ts — adicionar api.savePatterns(projectPath, content) (seguir padrão saveStatus) e opcionalmente api.loadPatterns.\n- client/src/contexts/BoardContext.tsx — incluir patterns na verificação de changes no polling; adicionar updatePatterns (semelhante a updateStatus) para salvar e atualizar boardData.\n- client/src/components/PatternsView.tsx — novo componente que reutiliza MarkdownViewer + CopyButton + Card; export default PatternsView.\n- client/src/App.tsx — adicionar activeView === 'patterns' render (TabsTrigger / TabsContent or top-level views) e importar/usar PatternsView. Atualizar Tabs / Navigation (ViewType já estendido) para mostrar nova aba.\n- mastra/index.js (opcional) — expor patterns.md via readProjectFiles OR adicionar ferramenta readPatterns para agentes (recomendação: garantir readProjectFiles já lê .md; se não, adicione explicitamente). \n\nPadrão do Projeto (observado)\n- API client segue funções nítidas por endpoint (ex: saveStatus, saveMilestones). Implementar savePatterns seguindo o mesmo padrão (fetch POST com JSON { projectPath, content }). Exemplo existente: saveStatus em client/src/lib/api.ts (linhas ~43-52).\n- Backend endpoints de arquivo (status, milestones) seguem readFile/writeFile sync com respostas JSON padrão. Espelhe o tratamento usado para llmGuide/projetoContext no GET /api/board e para POST /api/board/status.\n- UI usa Card + MarkdownViewer + CopyButton (ex.: App.tsx mostra llmGuide e projetoContext com esse padrão nas linhas ~303-310 e ~286-299).\n- BoardContext polling tem lógica de comparação: atualmente verifica tasks, status, llmGuide e projetoContext; adicione patterns nesta verificação. (Snippet existente: hasChanges = JSON.stringify(boardData.tasks) !== JSON.stringify(data.tasks) || boardData.status !== data.status || boardData.llmGuide !== data.llmGuide || boardData.projetoContext !== data.projetoContext ).\n\nExemplos reais (trechos observados — copiar estilo)\n- saveStatus (client/src/lib/api.ts):\n  async saveStatus(projectPath: string, content: string): Promise<void> {\n    const response = await fetch(`${API_BASE_URL}/board/status`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ projectPath, content })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Erro ao salvar status');\n    }\n  }\n\n- Uso de MarkdownViewer + CopyButton (client/src/App.tsx):\n  <Card className=\"p-6\">\n    <div className=\"flex justify-between items-center mb-4\">\n      <h2 className=\"text-lg font-semibold\">Guia LLM</h2>\n      <CopyButton content={boardData.llmGuide} projectPath={boardData.projectPath} />\n    </div>\n    <MarkdownViewer content={boardData.llmGuide} />\n  </Card>\n\n- Polling e comparação em BoardContext.tsx (trecho):\n  const hasChanges = JSON.stringify(boardData.tasks) !== JSON.stringify(data.tasks) ||\n    boardData.status !== data.status ||\n    boardData.llmGuide !== data.llmGuide ||\n    boardData.projetoContext !== data.projetoContext;\n\nObservação: siga exatamente os padrões de import (paths com '@/...') e tipos (import type { ... } from '@/types.js').\n\nPontos de atenção\n- Não alterar estrutura existente do BoardData sem atualizar tipos explicitamente (client/src/types.ts).\n- Preserve comportamento de polling e detecção de mudanças (adicionar apenas comparações necessárias).\n- Ao salvar arquivo no backend, siga a mesma atomicidade já usada (temp file + rename) — espelhar implementação de /api/board/status (ver server.js).\n- Crie patterns.md se não existir com conteúdo inicial LTS; backend GET /api/board deve sempre retornar um campo patterns (string) — mesmo que seja \"(Arquivo não encontrado)\" ou texto padrão.\n- Atualizar Navigation / ViewType para incluir 'patterns' e garantir que o Sidebar/Navigation exiba essa nova view.\n- Testar manualmente: 1) carregar projeto no app; 2) abrir aba Patterns; 3) editar via UI (se implementar edição) ou salvar via api.savePatterns; 4) confirmar polling atualiza a UI e agentes conseguem ler o arquivo via readProjectFiles.\n\nImplementação recomendada (resumo técnico)\n1) Types: client/src/types.ts -> BoardData add patterns: string; ViewType add 'patterns'.\n2) API client: client/src/lib/api.ts -> add async savePatterns(projectPath, content) similar a saveStatus; optionally add loadPatterns.\n3) Backend: backend/server.js ->\n   - Incluir reading of patterns.md when building board payload (same place llmGuide/projetoContext are read).\n   - Add POST /api/board/patterns that writes kanban-live/patterns.md (body: { projectPath, content }). Return success JSON.\n   - Ensure file creation if missing and use same write strategy (temp + rename) as other endpoints.\n4) BoardContext: client/src/contexts/BoardContext.tsx ->\n   - Add patterns comparison in polling hasChanges.\n   - Add updatePatterns(content) that calls api.savePatterns and setBoardData({ ...boardData, patterns: content }).\n5) UI: client/src/components/PatternsView.tsx -> new component that accepts content (string) and projectPath (string) from BoardContext (or props). Reuse Card + CopyButton + MarkdownViewer. Export default PatternsView.\n6) App.tsx: import PatternsView and render when activeView === 'patterns' (same style as guide/metadata). Also add TabsTrigger or view selector if necessary.\n7) kanban-live/patterns.md -> add initial LTS content (see suggested template abaixo).\n8) Mastra (opcional): ensure readProjectFiles reads patterns.md; if not, add a small tool readPatterns that returns contents of patterns.md and register it in mastra/index.js.\n\nConteúdo inicial sugerido para kanban-live/patterns.md (colocar no repo):\n# LTS / Patterns\n\n- React: prefer functional components + hooks; explicit types; use Context API for global state.\n- UI: reuse shadcn/ui components via CLI; place components em client/src/components/ui.\n- Tests: future plan — Vitest + React Testing Library.\n- Backend: file-based storage; use atomic writes (temp+rename) and simple lock to avoid races.\n- Contribuição: regras sobre IDs, timestamps, timeline (copiar do projeto-context.md).",
      "todos": [
        {
          "id": "td71185438",
          "concluido": false
        },
        {
          "id": "td71187672",
          "concluido": false
        },
        {
          "id": "td71184735",
          "concluido": false
        },
        {
          "id": "td71186464",
          "concluido": false
        },
        {
          "id": "td71184507",
          "concluido": false
        },
        {
          "id": "td71186646",
          "concluido": false
        },
        {
          "id": "td71181622",
          "concluido": false
        },
        {
          "id": "td71184600",
          "concluido": false
        },
        {
          "id": "td71183612",
          "concluido": false
        }
      ]
    },
    {
      "id": "t3704",
      "descricao": "Ter uma visão de \"git\" aqui no projeto",
      "detalhes": "Poder ver quais arquivos estão sendo rastreados etc.. É bom pra saber se esta trabalhando \"free\" naquela task especifica",
      "milestone": "m2972",
      "timeline": [
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T23:45:08-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:43:59.034-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:43:59-03:00"
        }
      ],
      "dataInicio": "2025-12-04T23:45:08-03:00"
    },
    {
      "id": "t5282",
      "descricao": "Implementar suporte a múltiplos modelos de IA na interface de gestão de agentes",
      "detalhes": "## O que fazer\n- Permitir que o usuário insira sua chave de API e selecione o modelo desejado na interface.\n- Implementar essa funcionalidade na aba de gestão de agentes.\n\n## Arquivos\n- `client/src/components/AgentManagement.tsx`: Criar ou modificar o componente para incluir campos de entrada para a chave de API e seleção de modelo.\n- `client/src/lib/api.ts`: Adicionar funções para gerenciar a troca de modelos de IA.\n\n## Observações\n- Revisar a documentação da Mastra sobre integração de modelos de IA para garantir que a implementação esteja alinhada com as melhores práticas.",
      "dataCriacao": "2025-12-05T17:34:15-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T17:34:15-03:00"
        }
      ],
      "milestone": "m3",
      "todos": [
        {
          "id": "td42219944",
          "texto": "Revisar a documentação da Mastra sobre integração de modelos de IA",
          "concluido": false
        },
        {
          "id": "td42214624",
          "texto": "Criar interface para entrada da chave de API e seleção do modelo",
          "concluido": false
        },
        {
          "id": "td42210581",
          "texto": "Implementar lógica para troca de modelos de IA na aplicação",
          "concluido": false
        },
        {
          "id": "td42218056",
          "texto": "Testar a integração com diferentes modelos de IA",
          "concluido": false
        },
        {
          "id": "td42212605",
          "texto": "Documentar a nova funcionalidade na wiki do projeto",
          "concluido": false
        }
      ]
    },
    {
      "id": "t8685",
      "descricao": "Criar agente para monitorar e atualizar documento de objetivos com commits.",
      "detalhes": "## O que fazer\nDesenvolver um agente que monitore o documento de objetivos e atualize com base em commits recentes. O agente deve registrar a última atualização com o commit e a data correspondente, permitindo que ele saiba a partir de onde buscar novas informações. A estrutura do documento de objetivos deve ser atualizada para incluir essa informação.\n\n## Arquivos\n- `mastra/agents/` - Localização dos agentes existentes para referência.\n- `backend/server.js` - Para integração com o sistema de controle de versão usando 'git log'.\n\n## Observações\n- Verificar como outros agentes estão estruturados para garantir consistência.\n- Testar o agente em diferentes cenários de atualização para garantir robustez.",
      "todos": [
        {
          "id": "td05272445",
          "texto": "Definir a estrutura do agente.",
          "concluido": false
        },
        {
          "id": "td05276351",
          "texto": "Implementar leitura do documento de objetivos e identificar a última atualização.",
          "concluido": false
        },
        {
          "id": "td05273537",
          "texto": "Integrar com sistema de controle de versão usando 'git log'.",
          "concluido": false
        },
        {
          "id": "td05272806",
          "texto": "Atualizar o documento com novas informações e registrar a nova última atualização.",
          "concluido": false
        },
        {
          "id": "td05271840",
          "texto": "Testar o agente em diferentes cenários de atualização.",
          "concluido": false
        }
      ],
      "milestone": "m3",
      "dataCriacao": "2025-12-07T20:53:48.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-07T20:53:48.000-03:00"
        }
      ]
    },
    {
      "id": "t5277",
      "descricao": "Melhorar a documentação e organização do projeto",
      "detalhes": "Expandir o contexto do projeto para incluir a árvore de diretórios, o package.json e exemplos de uso. Implementar documentação automatizada e criar uma seção de FAQ.",
      "todos": [
        {
          "id": "td52776991",
          "texto": "Adicionar seção de árvore de diretórios no documento",
          "concluido": false
        },
        {
          "id": "td52770617",
          "texto": "Incluir o conteúdo do package.json na documentação",
          "concluido": false
        },
        {
          "id": "td52771691",
          "texto": "Implementar geração de documentação automática com TypeDoc",
          "concluido": false
        },
        {
          "id": "td52775705",
          "texto": "Adicionar exemplos de uso práticos no guia de interação",
          "concluido": false
        },
        {
          "id": "td52777904",
          "texto": "Expandir a seção de operações no tasks.json com exemplos",
          "concluido": false
        },
        {
          "id": "td52775706",
          "texto": "Criar uma seção de perguntas frequentes (FAQ)",
          "concluido": false
        },
        {
          "id": "td52772531",
          "texto": "Definir um cronograma de revisões para a documentação",
          "concluido": false
        }
      ],
      "milestone": "m6021",
      "dataCriacao": "2025-12-07T21:53:05.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-07T21:53:05.000-03:00"
        }
      ]
    },
    {
      "id": "t3111",
      "descricao": "Expandir o contexto do projeto com árvore de diretórios, package.json e FAQ",
      "detalhes": "# Expansão do Contexto do Projeto\n\n## Estrutura de Diretórios\n",
      "todos": [],
      "dataCriacao": "2025-12-07T21:56:53.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-07T21:56:53.000-03:00"
        }
      ]
    },
    {
      "id": "t6185",
      "descricao": "Criar tool que lista estrutura de pastas + package.json para agentes",
      "detalhes": "## O que fazer\n- Desenvolver uma ferramenta que navega pela estrutura de pastas do projeto e retorna o conteúdo do package.json.\n\n## Arquivos\n- `mastra/tools/readProjectStructure.js`: Implementar a lógica para listar a estrutura de pastas e ler o package.json.\n- `backend/server.js`: Integrar a nova tool ao contexto do promptGenerator para que os agentes possam utilizá-la.\n\n## Observações\n- A ferramenta deve ser capaz de formatar a saída de forma legível, utilizando JSON ou Markdown.",
      "todos": [
        {
          "id": "td61856387",
          "texto": "Criar tool readProjectStructure.js que retorna tree + package.json",
          "concluido": false
        },
        {
          "id": "td61854746",
          "texto": "Adicionar readProjectStructure ao contexto do promptGenerator em server.js",
          "concluido": false
        },
        {
          "id": "td61856167",
          "texto": "Atualizar projeto-context.md com exemplos de uso das tools",
          "concluido": false
        },
        {
          "id": "td61850178",
          "texto": "Testar a nova tool com diferentes estruturas de projeto",
          "concluido": false
        },
        {
          "id": "td61859373",
          "texto": "Documentar a funcionalidade da nova tool na wiki do projeto",
          "concluido": false
        }
      ],
      "milestone": "m3",
      "dataCriacao": "2025-12-07T22:00:16.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-07T22:00:16.000-03:00"
        }
      ]
    },
    {
      "id": "t4895",
      "descricao": "Adicionar contador de tasks no hover de cada milestone na sidebar",
      "detalhes": "## O que fazer\nAdicionar um contador numérico que mostra a quantidade total de tasks associadas a cada milestone. O contador deve aparecer **APENAS no hover**, ao lado do título do milestone na barra lateral, com animação suave de fade-in.\n\n## Comportamento esperado\n- **Estado normal:** `[ponto colorido] Título do Milestone`\n- **Estado hover:** `[ponto colorido] Título do Milestone 5`\n- O número representa a soma de tasks em TODAS as colunas (backlog + todo + doing + done) associadas àquele milestone\n- Exemplo: \"MVP (5)\" = 5 tasks totais no milestone MVP\n\n## Arquivos a modificar\n\n### client/src/components/app-sidebar.tsx (182 linhas)\n**Linhas 39-102:** Seção de renderização dos milestones\n\n1. **Adicionar função helper** (após linha 48, dentro do componente):\n",
      "todos": [],
      "dataCriacao": "2025-12-08T01:23:44.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-08T01:23:44.000-03:00"
        }
      ]
    },
    {
      "id": "t3030",
      "descricao": "Criar componente ConfirmDeleteDialog reutilizável (AlertDialog) e substituir uso inline em TaskCard",
      "detalhes": "## O que fazer\nCriar um componente React+TypeScript reutilizável que encapsula o padrão de confirmação de exclusão (usando o AlertDialog do shadcn/ui já presente em client/src/components/ui/alert-dialog). Substituir a implementação inline atual em TaskCard.tsx por esse componente para centralizar comportamento, acessibilidade e estilização (botões, estado de loading, textos). Garantir tipagem, props claras e que o componente suporte: trigger como filho (asChild), itemType, itemName, onConfirm async, loading/disabled, texto customizável para título/descrição/ações.\n\n## Arquivos\n- Novo: client/src/components/ConfirmDeleteDialog.tsx (componente reutilizável)\n- Modificar: client/src/components/TaskCard.tsx\n  - Substituir o bloco AlertDialog existente (aprox. linhas 404-436) pelo uso de <ConfirmDeleteDialog />\n- Opcional (buscar e substituir): outros arquivos que usem AlertDialog para exclusão (faça uma busca por AlertDialogTrigger + Trash2 ou por title \"Excluir\") e troque por ConfirmDeleteDialog quando for confirmação de exclusão de item.\n\n## Observações\n- Padrões do projeto: use os componentes shadcn/ui via imports absolutos (ex: import { AlertDialog, AlertDialogTrigger, ... } from '@/components/ui/alert-dialog') e Button de '@/components/ui/button'.\n- Mantenha strings em português, use toast (sonner) apenas no handler (o TaskCard já chama toast). O componente ConfirmDeleteDialog NÃO deve executar a exclusão: apenas chama a função onConfirm passada como prop.\n- Tipos: importar type { ReactNode } de react e type definitions locais; tipar onConfirm: () => Promise<void> | void.\n- Estilo: preserve classes utilitárias tailwind já usadas no projeto (ex: className on Action button: \"bg-destructive text-destructive-foreground hover:bg-destructive/90\").\n- Trigger: componente deve aceitar children e renderizá-los dentro de <AlertDialogTrigger asChild> para compatibilidade com botões já existentes (ex: ícone Trash2 dentro de Button).\n- Lidando com evento stopPropagation: o TaskCard chamava onClick={(e)=> e.stopPropagation()} no trigger; ao substituir, preserve esse atributo no elemento trigger filho (o uso asChild garante que o Button filho continue recebendo props). Documente no componente que trigger deve aplicar stopPropagation se necessário.\n\nExemplo de uso no TaskCard (substituir trecho existente):\n\n1) Import:\nimport ConfirmDeleteDialog from '@/components/ConfirmDeleteDialog';\n\n2) Uso (substituir o bloco AlertDialog atual):\n<ConfirmDeleteDialog\n  itemType=\"Task\"\n  itemName={task.descricao}\n  onConfirm={handleDelete}\n  loading={isDeleting}\n>\n  {/* Trigger existente (preservar stopPropagation) */}\n  <Button\n    variant=\"ghost\"\n    size=\"sm\"\n    className=\"h-4 w-4 p-0 opacity-0 group-hover:opacity-100 transition-opacity hover:text-destructive\"\n    title=\"Excluir task\"\n    onClick={(e) => e.stopPropagation()}\n  >\n    <Trash2 className=\"h-3 w-3\" />\n  </Button>\n</ConfirmDeleteDialog>\n\nImplementação esperada do componente (resumo):\n- Props:\n  - itemType?: string (ex: \"Task\")\n  - itemName?: string\n  - onConfirm: () => Promise<void> | void\n  - loading?: boolean\n  - title?: string (fallback: `Excluir ${itemType}?`)\n  - description?: string (fallback com itemName interpolado)\n  - confirmLabel?: string (default \"Excluir\")\n  - cancelLabel?: string (default \"Cancelar\")\n  - children: ReactNode (trigger asChild)\n- Internamente usar:\n  import {\n    AlertDialog,\n    AlertDialogTrigger,\n    AlertDialogContent,\n    AlertDialogHeader,\n    AlertDialogTitle,\n    AlertDialogDescription,\n    AlertDialogFooter,\n    AlertDialogCancel,\n    AlertDialogAction\n  } from '@/components/ui/alert-dialog'\n- O AlertDialogAction chama onConfirm e deve suportar estado disabled quando loading=true.\n- O componente não chama toast; quem passar onConfirm (TaskCard) é responsável por toast/erros.\n\nCompatibilidade e testes manuais:\n- Após substituição, rodar app (client) e verificar que o botão de lixeira: abre modal, mostra título/descrição, Cancelar fecha, Excluir executa onConfirm e mostra estado \"Excluindo...\" quando loading.\n- Verificar que stopPropagation do trigger continua impedindo cliques de abrir detalhes ao clicar na lixeira.\n- Buscar por outras ocorrências de confirmações de exclusão e aplicar o componente quando fizer sentido (manter escopo pequeno se houver muitas ocorrências).\n",
      "todos": [
        {
          "id": "td30301062",
          "texto": "Criar client/src/components/ConfirmDeleteDialog.tsx: componente React+TS que encapsula AlertDialog (props: itemType?, itemName?, onConfirm, loading?, title?, description?, confirmLabel?, cancelLabel?, children)",
          "concluido": false
        },
        {
          "id": "td30302938",
          "texto": "Implementar lógica do AlertDialogContent/Header/Footer com AlertDialogAction chamando onConfirm e respeitando loading (mostrar \"Excluindo...\" quando loading=true) e classes de botão do projeto (bg-destructive etc.)",
          "concluido": false
        },
        {
          "id": "td30305483",
          "texto": "Modificar client/src/components/TaskCard.tsx: remover bloco inline AlertDialog (linhas ~404-436) e importar/usar <ConfirmDeleteDialog> passando itemType=\"Task\", itemName={task.descricao}, onConfirm={handleDelete}, loading={isDeleting}; preservar onClick={(e)=>e.stopPropagation()} no trigger Button filho",
          "concluido": false
        },
        {
          "id": "td30309013",
          "texto": "Buscar por outras confirmações de exclusão (grep por 'Excluir' ou uso de AlertDialog + Trash2) e substituir por ConfirmDeleteDialog onde apropriado, mantendo comportamento e textos existentes",
          "concluido": false
        },
        {
          "id": "td30305103",
          "texto": "Testar manualmente: abrir app, clicar ícone de lixeira no card, confirmar exclusão (verificar loading, toast da TaskCard e que o card é removido). Corrigir estilos/props se necessário.",
          "concluido": false
        }
      ],
      "milestone": "m6021",
      "dataCriacao": "2025-12-08T01:44:23.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-08T01:44:23.000-03:00"
        }
      ]
    },
    {
      "id": "t2720",
      "descricao": "Adicionar contador de tasks por milestone na barra lateral (badge)",
      "detalhes": "## O que fazer\nAdicionar um contador visível ao lado do título de cada milestone na sidebar (client/src/components/app-sidebar.tsx). O contador deve mostrar o número total de tasks associadas àquele milestone; no tooltip (title) exibir também \"concluídas/total\" usando os arrays atuais do boardData (backlog, todo, doing, done).\n\nUtilizar os componentes shadcn/ui já presentes (Badge) e padrões do projeto: imports via '@/components/ui/*', tratamento defensivo quando boardData for undefined e não alterar IDs de tasks/milestones.\n\n## Arquivos\n- client/src/components/app-sidebar.tsx\n  - Importar Badge: import { Badge } from '@/components/ui/badge'\n  - Criar função local para calcular counts a partir de boardData: total e done\n  - Renderizar o Badge dentro do bloco que mapeia boardData.milestones (linhas ~89-102), ao lado do <span className=\"truncate\">{milestone.titulo}</span>\n  - Adicionar title/tooltip simples: title={`Concluídas: ${done}/${total}`} (usa atributo title para acessibilidade simples)\n\nNão é necessária alteração no backend ou em types.ts pois Task já possui campo milestone. Garantir que a renderização seja estável quando boardData for null/undefined.\n\n## Observações\n- Padrões do projeto: usar imports absolutos com @/ e componentes shadcn já existentes (Badge). Evitar criar novos componentes shadcn via CLI para algo tão pequeno.\n- Mostrar o badge somente se total > 0 (opcional: exibir 0 de forma sutil se preferir). Recomenda-se exibir somente quando total > 0 para evitar poluição visual.\n- Tooltip via title é suficiente; se quiser um tooltip customizado, use o componente Tooltip existente, mas isso aumenta o escopo.\n- Testes manuais: atualizar kanban-live/tasks.json (ou via UI) e verificar que os números atualizam após polling/refresh do board.\n- Linhas aproximadas já observadas: a lista de milestones começa em app-sidebar.tsx linhas ~89-102 — inserir modificações neste bloco.\n",
      "todos": [
        {
          "id": "td27212568",
          "texto": "Adicionar import do Badge em client/src/components/app-sidebar.tsx: na seção de imports (próximo a import { Input } ...) adicione: import { Badge } from '@/components/ui/badge'",
          "concluido": false
        },
        {
          "id": "td27216619",
          "texto": "No topo do componente AppSidebar (após hooks useNavigation/useBoard, linha ~48) criar função getMilestoneCounts(milestoneId: string) que calcula total e done a partir de boardData.backlog|todo|doing|done (filtrar por task.milestone === milestoneId). Tratar boardData undefined retornando { total: 0, done: 0 }",
          "concluido": false
        },
        {
          "id": "td27219234",
          "texto": "Modificar o map de boardData.milestones (linhas ~89-102): dentro de <SidebarMenuSubButton> renderizar a badge ao lado do título: <span className='truncate'>{milestone.titulo}</span> → calcular const { total, done } = getMilestoneCounts(milestone.id) e inserir { total > 0 && <Badge className='ml-2' title={`Concluídas: ${done}/${total}`}>{total}</Badge> }",
          "concluido": false
        },
        {
          "id": "td27211076",
          "texto": "Garantir renderização resiliente: usar optional chaining em boardData?.backlog etc. e evitar crashes quando arrays estiverem vazios; formatar classes Tailwind para manter o alinhamento (ex: ml-2 text-xs) seguindo estilo existente",
          "concluido": false
        },
        {
          "id": "td27218220",
          "texto": "Testes manuais: abrir UI, verificar sidebar mostra badges; criar/associar tasks a um milestone e confirmar que o contador incrementa; mover task para done e confirmar tooltip mostra done/total; validar polling (ou reload) atualiza counts",
          "concluido": false
        }
      ],
      "milestone": "m2",
      "dataCriacao": "2025-12-08T02:21:02.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-08T02:21:02.000-03:00"
        }
      ]
    },
    {
      "id": "t9709",
      "descricao": "Refatorar modal de criação de tasks (AITaskCreatorDialog) para UI de chat mais estruturada e visual (React + shadcn/ui + MarkdownViewer)",
      "detalhes": "## O que fazer\nMelhorar o AITaskCreatorDialog para que a conversa com o agente fique mais clara, visual e fácil de transformar em task. Objetivos: mensagens com layout de chat (avatar/role), conteúdo do assistente renderizado via MarkdownViewer (código formatado + blocos), steps/tools exibidos como lista colapsável com badges e quick-actions (Salvar como draft / Finalizar / Regerar). Exibir preview da task final com conteúdo renderizado, lista de to-dos interativa e seletor de milestone antes de confirmar.\n\nUso de tecnologias/padrões do projeto:\n- React + TypeScript\n- shadcn/ui Dialog, Card, Button, Input\n- lucide-react (ícones)\n- sonner (toast)\n- componente existente MarkdownViewer (client/src/components/MarkdownViewer.tsx)\n- chamadas já existentes em client/src/lib/api.ts (chatCreateTask, finalizeCreateTask)\n\n## Arquivos (a modificar / criar)\n- Modificar: client/src/components/AITaskCreatorDialog.tsx\n  - Importar e usar novo componente ChatMessage\n  - Usar MarkdownViewer para renderizar assistant messages e createdTask.detalhes\n  - Refatorar o bloco de mensagens (map) para usar componente centralizado\n  - Melhorar preview final para mostrar markdown completo, todos com checkboxes e select de milestone (utilizar UI existente)\n  - Adicionar quick-action handlers que reutilizam api.chatCreateTask / api.finalizeCreateTask\n  - Linhas aproximadas no arquivo atual:\n    - Imports: ~5-13\n    - Render messages (map): ~152-180\n    - Loading indicator: ~181-190\n    - Preview da task: ~194-215\n    - Input area: ~217-238\n    - Action buttons: ~241-270\n\n- Criar: client/src/components/ChatMessage.tsx\n  - Componente reutilizável que recebe props: { message: Message, onQuickAction?: (action, message) => void }\n  - Renderiza: avatar/icon (user/assistant), conteúdo renderizado via MarkdownViewer, blocos de código com <pre> (MarkdownViewer já faz), seção collapsible para tools/steps com JSON resumido, quick-action buttons (Salvar como draft, Finalizar, Regerar sugestão) apenas para mensagens do assistant\n  - Usar shadcn Card + Button + lucide icons\n\n- Opcional: pequenas CSS/classes tailwind em AITaskCreatorDialog (já segue padrão)\n\n## Observações\n- Reaproveitar MarkdownViewer (client/src/components/MarkdownViewer.tsx) para garantir que blocos de código e inline code fiquem bonitos sem adicionar novas libs.\n- Seguir padrão de imports do projeto: import { X } from '@/components/ui/X' e import type { Task } from '@/types.js' quando precisar de tipos.\n- Manter lógica existente de conversationHistory e api calls; quick-actions devem apenas reutilizar essas chamadas (ex: bottões que chamam api.finalizeCreateTask com conversationHistory ou api.chatCreateTask para pedir regeneração).\n- Não alterar endpoints backend; trabalhar apenas no frontend.\n- Preservar acessibilidade: buttons com aria-labels e foco visível.\n- Testar manualmente: abrir modal, fazer 2-3 trocas com agente, clicar Criar Task e Confirmar e Adicionar.\n- Milestone sugerida: m3 (Integração IA).\n",
      "todos": [
        {
          "id": "td97094699",
          "texto": "Criar componente ChatMessage.tsx em client/src/components/ que aceita props { message, onQuickAction } e renderiza: avatar (lucide), conteúdo com <MarkdownViewer content={message.content} />, seção collapsible 'Ferramentas usadas' mostrando cada step como badge + resumo JSON, e quick-action buttons (Salvar como draft, Regerar, Finalizar) — usar shadcn Card/Button + classes tailwind.",
          "concluido": false
        },
        {
          "id": "td97097686",
          "texto": "Modificar imports no topo de client/src/components/AITaskCreatorDialog.tsx (linhas ~5-13): adicionar import ChatMessage from '@/components/ChatMessage' e importar MarkdownViewer; manter api/imports existentes (sonner, lucide).",
          "concluido": false
        },
        {
          "id": "td97097378",
          "texto": "Refatorar renderização de messages em AITaskCreatorDialog.tsx (bloco atual lines ~151-180): substituir map inline por <ChatMessage key=... message={message} onQuickAction={handleQuickAction} />; mover logic de steps display para o novo componente; garantir auto-scroll mantém o mesmo comportamento.",
          "concluido": false
        },
        {
          "id": "td97093074",
          "texto": "Melhorar Preview da Task em AITaskCreatorDialog.tsx (bloco atual ~194-215): quando isFinalized true mostrar Card expandido com:\n- Título (createdTask.descricao)\n- MarkdownViewer para createdTask.detalhes (full, não line-clamp)\n- Lista de createdTask.todos com checkboxes interativos (usar state local para marcar)\n- Select de milestone (usar array de milestones do contexto ou API se necessário) e botão 'Confirmar e Adicionar' que chama handleConfirmTask existente.",
          "concluido": false
        },
        {
          "id": "td97095757",
          "texto": "Adicionar handlers quick-action em AITaskCreatorDialog.tsx (criar funções handleQuickAction / handleRegenerate):\n- handleQuickAction('finalize') -> chama api.finalizeCreateTask(projectPath, conversationHistory) e atualiza createdTask/isFinalized\n- handleQuickAction('regenerate') -> chama api.chatCreateTask(projectPath, 'Regenere a sugestão mantendo contexto', conversationHistory) e adiciona resposta às messages\n- Garantir toasts via sonner e bloquear UI durante chamadas; integrar com isLoading",
          "concluido": false
        }
      ],
      "milestone": "m3",
      "dataCriacao": "2025-12-08T02:35:19.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-08T02:35:19.000-03:00"
        }
      ]
    },
    {
      "id": "t1719",
      "descricao": "Sobre o projeto",
      "detalhes": "Imaginando que podemos ter um \"link online\", pode ser legal ter uma parte mais \"comercial\" de sobre o projeto",
      "milestone": "m4",
      "dataCriacao": "2025-12-11T23:49:11-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-11T23:49:11-03:00"
        }
      ]
    },
    {
      "id": "t8428",
      "descricao": "Auditar e preparar o repositório para ser publicado como open-source (remover/mitigar secrets, adicionar docs/licença, guidelines, e recomendar estratégia de distribuição)",
      "detalhes": "Contexto rápido\n- Esta task é um checklist/epic para avaliar se o projeto pode ser publicado publicamente e executar as mudanças mínimas necessárias para torná-lo seguro e consumível por outros.\n- Repositório alvo: /Users/filippiaraujo/Documents/Projetos/live-kanban/kanban-live\n- Milestone sugerida já presente: m0916 (Open Source)\n\nArquivos relacionados (inspecionar / criar / modificar)\n- /Users/filippiaraujo/Documents/Projetos/live-kanban/kanban-live/backend/server.js — contém lógica de cloud sync que atualmente salva token no tasks.json (linhas ~82-88). Precisa revisão (não salvar secrets em tasks.json) e documentação de comportamento.\n- /Users/filippiaraujo/Documents/Projetos/live-kanban/kanban-live/kanban-live/tasks.json — arquivo de configuração do projeto; pode conter campo cloudSync.token. Must audit and remove secrets from here.\n- /Users/filippiaraujo/Documents/Projetos/live-kanban/kanban-live/package.json (root) — license está definido mas author vazia; atualizar metadata repository, homepage, bugs, license.\n- /Users/filippiaraujo/Documents/Projetos/live-kanban/kanban-live/client/package.json e /backend/package.json — checar scripts e dependências e adicionar recomendações de build/publish onde fizer sentido.\n- .gitignore (root) — confirmar que existe e inclui .env, node_modules, build artefacts; criar se ausente.\n- README.md, LICENSE, CONTRIBUTING.md, SECURITY.md, CODE_OF_CONDUCT.md — criar/atualizar com instruções de uso (clone vs npm), setup local, cloudSync explicação e como reportar vulnerabilidades.\n- .env.example in root, client/, backend/ — criar para documentar env vars usados (e.g. LIVEKANBAN_CLOUD_URL), garantindo que valores reais não sejam commitados.\n- CI files (/.github/workflows) — criar workflow básico para lint/build/test e secret-scan (opcional) antes de publicar.\n\nPadrões do projeto observados\n- Backend salva tokens temporariamente no tasks.json durante sync (veja backend/server.js — trecho que escreve result.token em tasks.json). Isso é um risco: tasks.json é parte do projeto e pode ser publicado.\n- O projeto é file-based (kanban-live/tasks.json) e a aplicação espera encontrar/editar esse arquivo; portanto precisamos documentar que tasks.json não deve conter segredos e fornecer formato alternativo para credenciais (env vars) ou instruções de uso do cloud sync.\n- Scripts npm já definidos (root/package.json scripts: start/dev/install:all). License field existe (MIT) mas author está vazio — preencher metadados é recomendado para publicação.\n\nRecomendações de distribuição (prós/cons e escolha sugerida)\n- Distribuição por GitHub repo (recomendado): permite clone, issues, releases, contribuições e fácil auditoria. Instruir usuários no README como clonar e executar (npm install && npm run dev). Fornecer releases (tar/zip) e tags sem incluir secrets.\n- Publicação no npm: geralmente não faz sentido para app full-stack. Pode ser útil publicar apenas bibliotecas/ componentes reutilizáveis (ex: se extrair UI library). Se escolher npm, extrair o pacote em um sub-pacote (client-ui) com package.json próprio.\n- Docker image: distribuir via Docker Hub/GHCR é uma boa opção para usuários que querem rodar sem instalar Node localmente.\n\nRiscos/observações técnicas críticas\n- backend/server.js grava token do serviço de cloud sync em tasks.json (linhas ~82-88). Como tasks.json vive no repositório e pode ser commitado, isso é um leak de credenciais. Necessário evitar salvar token em arquivos do repositório ou criptografar e documentar claramente.\n- tasks.json pode conter outros dados sensíveis (p.ex. urls/token em cloudSync). Fazer scan e limpar antes de publicar.\n- Não inventar segredos: se tokens ou credenciais existirem no repo Histórico (git), é preciso instruir remoção via git filter-repo ou BFG antes publicar.\n\nTrechos reais do código (referência rápida)\n- backend/server.js (parte relevante):\n  - Quando a resposta do cloud retorna isNew e result.slug/result.token:\n    data.cloudSync.slug = result.slug;\n    data.cloudSync.token = result.token;   <-- NÃO salvar token no tasks.json\n    data.cloudSync.url = result.url;\n    await fs.writeFile(tasksFile, JSON.stringify(data, null, 2), 'utf8');\n  (arquivo: backend/server.js, procurar trecho syncToCloud -> linhas 82-88)\n\nEstratégia mínima para tornar open-source (passos claros e não-invasivos)\n1) Auditar e remover secrets do repositório e tasks.json\n2) Proibir escrita de secrets em arquivos versionados (corrigir backend/server.js)\n3) Adicionar .env.example e instruções no README\n4) Criar documentação (LICENSE, README, CONTRIBUTING, SECURITY) e ajustar package.json metadata\n5) Implementar varredura por secrets e CI básico\n6) Decidir e documentar forma de distribuição (repo + optional Docker)\n\nPontos de atenção técnicos\n- Ao alterar backend/server.js, preserve comportamento de cloudSync (slug/url) mas NÃO persista token em tasks.json. Se token é necessário para futuros updates, documentar fluxo: usuários config (env) ou usar server-side storage fora do repo. Alternativamente, encrypt token with user-provided passphrase (complexo — prefer documentar env var).\n- Se repository já contém tokens no histórico Git, fornecer instruções passo-a-passo para removê-los de histórico usando BFG/git filter-repo e como rotacionar credenciais.\n- Comunicar aos usuários que tasks.json nunca deve conter secrets; adicionar validação no servidor que rejeite salvar quando tasks.cloudSync.token estiver presente.\n\nExemplos de arquivos/trechos a serem adicionados (templates)\n- README.md: instruções de clone, instalação, run, developer notes, how to disable cloud sync, publishing guidance (clone vs docker). Incluir seção SECURITY com steps to report vulnerabilities.\n- .env.example:\n  LIVEKANBAN_CLOUD_URL=https://api.livekanban.dev\n  # Se a cloud sync exigir token do usuário, documentar como obtê-lo e onde armazenar (prefer .env local) \n- backend/server.js: pequeno patch (ver To-dos) para não salvar token e logar aviso.\n- .gitignore: node_modules/\n  /client/node_modules/\n  /backend/node_modules/\n  .env\n  *.local\n  *.log\n\nCI: GitHub Actions workflow (optional) com steps:\n- checkout\n- run secret scanner (detect-secrets or trufflehog) — as step optional and non-blocking at first\n- run npm ci && npm run build (client) and node backend tests (if any)\n\n",
      "milestone": "m0916",
      "dataCriacao": "2025-12-12T01:00:58-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-12T01:00:58-03:00"
        }
      ],
      "todos": [
        {
          "id": "td16917097",
          "concluido": false
        },
        {
          "id": "td16911316",
          "concluido": false
        },
        {
          "id": "td16910142",
          "concluido": false
        },
        {
          "id": "td16912106",
          "concluido": false
        },
        {
          "id": "td16913922",
          "concluido": false
        },
        {
          "id": "td16911329",
          "concluido": false
        },
        {
          "id": "td16910958",
          "concluido": false
        },
        {
          "id": "td16912400",
          "concluido": false
        },
        {
          "id": "td16918071",
          "concluido": false
        },
        {
          "id": "td16919986",
          "concluido": false
        },
        {
          "id": "td16919291",
          "concluido": false
        }
      ]
    },
    {
      "id": "t4078",
      "descricao": "Suavizar transição DnD entre colunas para eliminar glitch de reposicionamento",
      "detalhes": "## O que fazer\n\nCorrigir o pequeno \"glitch\" visual ao arrastar um card entre colunas usando @hello-pangea/dnd, deixando o movimento mais natural (estilo Trello). A solução combina: (1) estado local de pré-visualização durante o drag (para evitar reposicionamentos inesperados quando há filtros), (2) melhoria de animação/estilos do card arrastado e (3) placeholder mais estável na coluna destino. Não é necessário trocar a lib de DnD — ajustaremos a lógica de cálculo de índice e a renderização responsável pelo placeholder.\n\nImplementação técnica (alto nível):\n- Adicionar handlers onDragStart e onDragUpdate no KanbanBoard para manter um estado \"dragPreview\" (mapa columnId → array de taskIds) que represente como a UI deve parecer durante o arraste sem alterar imediatamente boardData.\n- Durante o drag, calcular uma lista de preview por coluna (removendo o item da origem e inserindo na coluna destino na posição visual desejada). Passar esse preview para KanbanColumn como prop (ex: previewTaskIds) para que a coluna desenhe um placeholder estável entre cards.\n- KanbanColumn deverá renderizar o placeholder (um gap/elemento neutro com altura igual ao card) na posição determinada pelo preview, além de continuar a usar provided.placeholder do DnD (isso mantém compatibilidade com a API da lib).\n- No TaskCard, suavizar a animação do item arrastado: substituir a rotação/transform exagerada por uma escala + shadow + transition curta (ex: scale-105, shadow-lg, transition-transform duration-150 ease-out). Isso dá sensação de leveza sem pular o layout.\n- Ajustar cálculo de inserção quando houver filtros ativos: usar as listas COMPLETAS (boardData.tasks[col]) para encontrar o índice real e, enquanto arrasta, usar somente o preview local para a UI. Só ao finalizar (onDragEnd) persistir a mudança chamando updateTasks como já existe.\n\n## Arquivos\n\n- client/src/components/KanbanBoard.tsx\n  - Adicionar onDragStart e onDragUpdate handlers\n  - Criar estado local: dragPreview (Record<Column, string[]>) e draggingItem { id, fromColumn }\n  - Calcular preview a partir de boardData.tasks (full lists) + destination index do evento\n  - Passar preview para KanbanColumn via nova prop previewTaskIds\n\n- client/src/components/KanbanColumn.tsx\n  - Aceitar nova prop previewTaskIds?: string[]\n  - Antes de renderizar tasks.map, usar previewTaskIds para inserir um elemento placeholder (gap) no índice indicado\n  - Garantir que provided.placeholder continue presente (não remover)\n  - Manter classes de overflow e altura; adicionar transições sutis em background quando snapshot.isDraggingOver\n\n- client/src/components/TaskCard.tsx\n  - Atualizar classes visuais do card arrastado: trocar rotate-2 por scale/translate e adicionar transition-transform duration-150 ease-out e shadow mais natural\n  - Garantir isDragDisabled continua respeitado quando editando\n\n- client/src/contexts/BoardContext.tsx (opcional)\n  - Rever comportamento de updateTasks: manter comportamento atual (salva e setBoardData) — mas garantir que a UI de preview local não seja sobrescrita repentinamente por polling (ver observações)\n\n## Observações\n\n- Por que isso resolve o glitch: hoje a UI usa tasks filtradas para calcular posições visuais; quando a lista visível é diferente da lista completa, o cálculo de inserção pode causar reposicionamento inesperado. A solução evita alterar o estado global durante o drag e faz a coluna renderizar exatamente a posição esperada via preview local.\n- Polling: BoardContext faz polling a cada 2s. Para evitar sobrescrita visual durante um drag longo, ignore atualizações do polling enquanto houver draggingItem (ou torne o polling silencioso enquanto dragPreview ativo). Implementar isso no effect de polling é opcional, mas recomendado para UX consistente.\n- Placeholders: mantenha provided.placeholder do DnD — o preview é complementar (um gap estático) para que altura/scroll não pule.\n- A implementação deve manter compatibilidade com filtros (selectedMilestones / searchQuery). O preview deve ser calculado a partir do boardData.tasks (lista completa) mas renderizado apenas para dar a sensação correta ao usuário.\n- Não introduzir novas dependências (ex: framer-motion). Use Tailwind + classes CSS existentes para animações.\n",
      "todos": [
        {
          "id": "td40783020",
          "texto": "Adicionar estado local em KanbanBoard: draggingItem {id, from}, dragPreview: Record<column, taskId[]> e handlers onDragStart, onDragUpdate",
          "concluido": false
        },
        {
          "id": "td40797816",
          "texto": "Calcular preview durante onDragUpdate: remover item da coluna de origem e inserir na coluna destino na posição visual (usar boardData.tasks como fonte de verdade)",
          "concluido": false
        },
        {
          "id": "td40792144",
          "texto": "Modificar KanbanColumn para aceitar previewTaskIds prop e renderizar um placeholder (gap element) na posição indicada, mantendo provided.placeholder",
          "concluido": false
        },
        {
          "id": "td40794265",
          "texto": "Ajustar TaskCard styling: trocar rotate-2 por scale-105 + shadow-lg + transition-transform duration-150 ease-out para suavizar aparência do card arrastado",
          "concluido": false
        },
        {
          "id": "td40799147",
          "texto": "No onDragEnd (KanbanBoard), aplicar a lógica atual de updateTasks usando o cálculo robusto de índices (baseado nas listas completas) e limpar dragPreview/draggingItem; opcional: suspender polling enquanto draggingItem existir",
          "concluido": false
        }
      ],
      "milestone": "m3875",
      "dataCriacao": "2025-12-12T15:25:24.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-12T15:25:24.000-03:00"
        }
      ]
    }
  ],
  "todo": [
    {
      "id": "t6792",
      "descricao": "Refatorar modal de Task para layout em duas colunas (meta/ações à esquerda, textos à direita)",
      "detalhes": "## O que fazer\n\nRefatorar o modal de detalhes da task (DialogContent) em client/src/components/TaskCard.tsx para um layout em duas colunas que melhora a leitura: coluna esquerda estreita para metadata, checklist e ações rápidas; coluna direita principal para textos longos (Detalhes, Resultado) e timeline. Manter todas as lógicas, handlers e states atuais (detalhes, resultado, todos, selectedMilestone, hasUnsavedChanges, handleSaveDetails, handleCancelDialog, handlers de to-dos, enrich, copy) — apenas reorganizar a estrutura e ajustar classes Tailwind para scroll/respnsividade.\n\nRequisitos técnicos e padrões do projeto:\n- Usar Tailwind CSS util classes já presentes no arquivo (ex: bg-background, text-muted-foreground, focus:ring-primary).\n- Não alterar primitives do Dialog (client/src/components/ui/dialog.tsx).\n- Manter DialogHeader sticky; DialogContent continua com max-w-2xl e max-h-[80vh].\n- Cada coluna deve ter overflow-y-auto independente (scroll separado) e respeitar o max-height do modal.\n- Responsividade: em telas < md as colunas empilham (flex-col); em md+ usar layout em linha (flex-row) com coluna esquerda fixa (recomendo w-72 / md:w-[280px]) e direita flex-1.\n- Usar Collapsible existente para Resultado; timeline pode iniciar colapsada por padrão.\n- Seguir convenções do projeto: não criar novos componentes shadcn sem CLI; se extrair subcomponentes, deixá-los como funções internas no mesmo arquivo para reduzir escopo.\n\n## Arquivos\n\n- [MODIFICAR] client/src/components/TaskCard.tsx\n  - Ajustar JSX dentro de <DialogContent className=\"...\">: substituir o container vertical atual por um wrapper que contém duas colunas.\n  - Movimentar elementos:\n    - Coluna esquerda (left column): selector de milestone, resumo compacto de datas (Criada/Iniciada/Finalizada), To-dos (lista + input), ações rápidas (Enrich, Copy path, Copy full context) e botão de excluir (AlertDialog trigger).\n    - Coluna direita (right column): textarea Detalhes (maior), Collapsible Resultado, Timeline completa (lista de movimentações com scroll independente).\n  - Ajustar classes Tailwind para:\n    - Wrapper: `flex flex-col md:flex-row gap-6 px-6 py-4 overflow-hidden flex-1`.\n    - Left: `w-72 md:w-[280px] flex-shrink-0 overflow-y-auto pr-2 md:pr-4 border-b md:border-b-0 md:border-r md:pr-6` (sem border-r em mobile).\n    - Right: `flex-1 overflow-y-auto pl-2 md:pl-6`.\n    - Garantir que cada coluna respeite `max-h` relativo ao DialogContent (usar `overflow-y-auto flex-1` onde apropriado).\n- [NÃO MODIFICAR] client/src/components/ui/dialog.tsx\n- [REFERÊNCIA] manter uso de componentes: Button, Collapsible, AlertDialog, Card — já no arquivo.\n\n## Observações\n\n- Preservar IDs e geração de todo IDs (`td${Date.now()...}`) e regras de persistência de task.\n- Não mexer na lógica de salvar (onUpdateTask) — apenas assegurar que os inputs/areas estejam ligados aos states existentes.\n- A timeline pode iniciar colapsada por padrão (usar Collapsible com `open={false}`) para evitar poluição visual; deixar claro no código como abrir por default se necessário.\n- Acessibilidade: manter `label` elementos, `title` em botões e adicionar `aria-label` quando o botão for apenas ícone.\n- Testes manuais mínimos após implementação: salvar/cancelar com mudanças não salvas (toast warning), adicionar/deletar/toogle to-dos, enrich e copy path/context, fluxo de salvar com milestone alterado, comportamento responsivo (mobile empilha) e rolagem independente das colunas.\n- Se for necessário extrair funções auxiliares para organizar JSX, crie funções internas no mesmo arquivo (ex: renderLeftColumn(), renderRightColumn()) em vez de novos arquivos.\n",
      "todos": [
        {
          "id": "td67929479",
          "texto": "Modificar JSX do DialogContent em client/src/components/TaskCard.tsx para um wrapper `flex flex-col md:flex-row` com duas colunas (left fixed width `w-72/ md:w-[280px]`, right `flex-1`) e `overflow-hidden flex-1` no wrapper.",
          "concluido": false
        },
        {
          "id": "td67928627",
          "texto": "Mover e adaptar elementos para a coluna esquerda: select de milestone, resumo compacto de datas, lista de to-dos + input de adicionar, ações rápidas (Enrich, Copy path, Copy contexto) e botão de excluir; aplicar `overflow-y-auto` na coluna.",
          "concluido": false
        },
        {
          "id": "td67926462",
          "texto": "Mover e adaptar elementos para a coluna direita: textarea Detalhes (min-h maior), Collapsible Resultado (inicialmente fechado), e timeline completa com lista scrollável; aplicar `overflow-y-auto` e garantir espaçamento (`pl-2 md:pl-6`).",
          "concluido": false
        },
        {
          "id": "td67924613",
          "texto": "Ajustar classes Tailwind para separador visual entre colunas (border-r em md), manter DialogHeader sticky e garantir DialogContent mantém `max-w-2xl max-h-[80vh]`.",
          "concluido": false
        },
        {
          "id": "td67927937",
          "texto": "Preservar e conectar todos os states/handlers existentes (detalhes, resultado, todos, selectedMilestone, hasUnsavedChanges, handleSaveDetails, handleCancelDialog, handleEnrichTask, handleCopyPath, handleCopyFullContext) sem alterar sua lógica.",
          "concluido": false
        },
        {
          "id": "td67927335",
          "texto": "Testar manualmente: salvar/cancelar com alterações não salvas, adicionar/remover/toggle to-dos, enrich & copy, timeline open/close, e responsividade (mobile < md empilha colunas; md+ em duas colunas com scroll independente).",
          "concluido": false
        }
      ],
      "milestone": "m2",
      "dataCriacao": "2025-12-08T03:21:36.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-08T03:21:36.000-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-08T03:23:22.354-03:00"
        }
      ]
    }
  ],
  "doing": [],
  "done": [
    {
      "id": "t6980",
      "descricao": "Preencher automaticamente o campo milestone ao criar uma task quando um milestone estiver selecionado",
      "detalhes": "O que precisa ser feito:\n- Quando o usuário tiver um milestone selecionado no contexto/filtro lateral, o modal/fluxo de criação de nova task deve pré-definir o campo milestone com esse ID e salvar a task já associada ao milestone.\n- Implementar no frontend (React + TypeScript) aproveitando o BoardContext para expor selectedMilestone; garantir que o modal de criação (shadcn Dialog) use esse valor como valor inicial e que a API client envie a task com o campo milestone.\n\nArquivos a modificar (sugestões precisas):\n- client/src/contexts/BoardContext.tsx — adicionar/expor selectedMilestone: string | null e setters (preservar padrões de Context API).\n- client/src/components/Header.tsx — quando abrir o modal de criar task, passar selectedMilestone como valor inicial para o formulário de criação.\n- client/src/components/TaskCreateDialog.tsx (ou o componente responsável pelo modal de criação) — pré-preencher o campo milestone no form, permitir alteração pelo usuário e validar antes de salvar; usar componentes shadcn/ui Dialog/Form.\n- client/src/lib/api.ts — garantir que a função que salva/cria tasks envie o objeto Task com o campo milestone (se presente) ao backend (POST /api/board/tasks ou PUT equivalente).\n- client/src/types.ts — confirmar que Task tem milestone?: string (já esperado) e ajustar imports se necessário (use .js import conforme padrão do projeto).\n- backend/server.js — validar que o endpoint que recebe a atualização aceita e persiste o campo milestone sem alterar a estrutura do tasks.json.\n- kanban-live/tasks.json — não editar manualmente aqui durante a implementação; apenas como alvo da API quando salvar.\n\nObservações:\n- ⚠️ Use o shadcn CLI se for adicionar/modificar componentes shadcn (npx shadcn@latest add dialog) — seguir padrão do projeto (componentes em src/components/ui/).\n- ⚠️ Preserve a estrutura do tasks.json e IDs (não renomeie IDs existentes). Valide JSON após salvar (jq ou similar).\n- ⚠️ Não introduza dependências novas sem aprovação; siga Tailwind v4 e padrões do projeto.\n- ✅ Ao implementar, inclua um pequeno teste manual: selecionar um milestone, abrir modal criar task, confirmar que o form vem preenchido e que, após salvar, a task aparece associada àquele milestone no board e no tasks.json.",
      "milestone": "m2",
      "dataCriacao": "2025-12-04T23:47:36-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T23:47:36-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:37:47-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:38:25-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:38:52-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T03:39:48.046-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:39:48-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:43:40.628-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:43:40-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-08T03:01:27.738-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-08T03:07:48.215-03:00"
        }
      ],
      "todos": [
        {
          "id": "td91997331",
          "texto": "Adicionar selectedMilestone ao BoardContext.tsx: state, setter e tipo (string | null) e exportar via useBoard()",
          "concluido": false
        },
        {
          "id": "td91995340",
          "texto": "Atualizar o componente que lida com seleção de milestones (ex: MilestoneProgress/Sidebar/Dropdown) para chamar setSelectedMilestone quando o usuário selecionar um filtro",
          "concluido": false
        },
        {
          "id": "td91992323",
          "texto": "Modificar o fluxo de criação: em Header.tsx abrir o modal de criação passando selectedMilestone; criar/atualizar client/src/components/TaskCreateDialog.tsx para pré-preencher o campo milestone no formulário (permitir override)",
          "concluido": false
        },
        {
          "id": "td91995109",
          "texto": "Garantir que client/src/lib/api.ts inclua o campo milestone ao enviar a nova task ao backend e que o payload siga o schema Task (dataCriacao + timeline)",
          "concluido": false
        },
        {
          "id": "td91992406",
          "texto": "Verificar backend/server.js para assegurar que o endpoint persiste o campo milestone sem quebrar a estrutura do tasks.json; adicionar validação mínima se necessário",
          "concluido": false
        },
        {
          "id": "td91993614",
          "texto": "Testes manuais e verificação: selecionar milestone m2, criar task, validar tasks.json (JSON válido), confirmar badge de milestone no card e cálculo de progresso",
          "concluido": false
        }
      ],
      "dataInicio": "2025-12-05T03:39:48.046-03:00",
      "dataFinalizacao": "2025-12-08T03:07:48.215-03:00"
    },
    {
      "id": "t9225",
      "descricao": "Mover botão 'Criar com IA' para ficar ao lado do botão 'Criar' no Header, reaproveitando o modal de criação pré-preenchido pela IA.",
      "detalhes": "Escopo:\n- Frontend (React + TypeScript). Não mexer no backend/endpoints.\n\nComportamento esperado:\n- Não criar um novo botão: mover a instância existente do botão \"Criar com IA\" para ficar imediatamente ao lado do botão de criar normal no Header (client/src/components/Header.tsx).\n- Preservar a lógica atual: ao clicar, o botão deve chamar a rotina que consome POST /api/agents/enhance-task (via client/src/lib/api.ts ou função já existente) e abrir o modal de criação com os campos pré-preenchidos pela IA (descrição, detalhes, milestone, to-dos quando aplicável).\n- Usuário pode editar o conteúdo pré-preenchido antes de salvar; fluxo de criação permanece o mesmo.\n- Tratamento de loading/erro: manter toasts existentes (sonner) e fallback para abrir o modal vazio caso a geração falhe.\n- Acessibilidade: botão deve ter aria-label apropriado, foco previsível ao abrir o modal e ser navegável por teclado.\n\nRequisitos técnicos / Padrões:\n- Usar componentes shadcn/ui (Button, Dialog) e utilitários do projeto (cn()).\n- Importar tipos TypeScript corretos quando necessário (ex: import type { Task } from '@/types.js').\n- Manter caminhos de import exatamente como no projeto e seguir convenções (sem criar componentes shadcn manualmente).\n- Não alterar endpoints nem adicionar novos; apenas consumir o endpoint já disponível.\n\nArquivos principais a revisar/editar:\n- client/src/components/Header.tsx (mover botão e ajustar layout/responsividade)\n- Arquivo atual onde o botão IA está localizado (remover instância antiga)\n- client/src/lib/api.ts (verificar/reusar função que chama /api/agents/enhance-task; se já existir, apenas importar)\n- Modal de criação (reutilizar o Dialog existente; garantir que aceita prefill/initialData — adaptar se necessário sem quebrar o fluxo atual)\n\nCritérios de aceitação:\n- O botão \"Criar com IA\" aparece lado a lado com o botão de criar no Header em desktop e mobile (layout responsivo aceitável).\n- Ao clicar, o modal abre com conteúdo sugerido pela IA; usuário pode editar; salvar cria a task como antes.\n- Se a chamada à IA falhar, mostrar toast de erro e abrir modal vazio como fallback.\n- Não há duplicidade do botão em nenhuma tela; a instância antiga foi removida.\n- Testado em fluxos: sucesso IA → editar → salvar; falha IA → fallback modal; acessibilidade teclado/foco.\n",
      "todos": [
        {
          "id": "td92252088",
          "texto": "Localizar o arquivo com a instância atual do botão \"Criar com IA\" e revisar o handler/API já usado.",
          "concluido": false
        },
        {
          "id": "td92251894",
          "texto": "Abrir client/src/components/Header.tsx e posicionar o botão existente ao lado do botão de criar; ajustar markup/Tailwind para alinhamento e responsividade.",
          "concluido": false
        },
        {
          "id": "td92255857",
          "texto": "Importar/reutilizar a função que chama POST /api/agents/enhance-task em client/src/lib/api.ts (se já existir) ou apontar para a rotina já usada pelo fluxo ✨.",
          "concluido": false
        },
        {
          "id": "td92259634",
          "texto": "Garantir que o modal de criação (Dialog) aceita dados pré-preenchidos (initialData/prefill). Se necessário, adaptar o modal para aceitar props de prefill sem alterar o comportamento de criação.",
          "concluido": false
        },
        {
          "id": "td92252765",
          "texto": "Remover a instância antiga do botão no local original para evitar duplicidade.",
          "concluido": false
        },
        {
          "id": "td92259484",
          "texto": "Testar fluxos principais (geração IA bem-sucedida → editar → salvar; geração falha → fallback modal vazio), responsividade e foco/acessibilidade.",
          "concluido": false
        },
        {
          "id": "td92258274",
          "texto": "Fazer commit em branch feature/mover-botao-criar-ia com mensagem descritiva em português e abrir PR com screenshots (antes/depois) se possível.",
          "concluido": false
        }
      ],
      "milestone": "m2",
      "dataCriacao": "2025-12-05T03:18:29.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T03:18:29.000-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T20:59:22.374-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-07T20:10:09.031-03:00"
        }
      ],
      "dataInicio": "2025-12-05T20:59:22.374-03:00",
      "dataFinalizacao": "2025-12-07T20:10:09.031-03:00"
    },
    {
      "id": "t1010",
      "descricao": "ter opção de, ao criar uma task nova, pedir pro agente deixar ela mais \"estruturada\", onde ele pega mais contexto sobre o projeto e tals, ele meio que \"LLMiza\" o textinho da task, pra ficar melhor, sabe?",
      "milestone": "m3",
      "detalhes": "- Esse agente precisa ter o contexto do projeto pra fazer isso\n- Ele precisa ter todo contexto de como funciona o nosso tasks.json e tudo mais do projeto pra conseguir usar os to-dos, detalhes, milestones, etc",
      "todos": [
        {
          "id": "td0491",
          "texto": "Entender como podemos usar o workflow da mastra pra isso (ver se faz sentido)",
          "concluido": false
        },
        {
          "id": "td9398",
          "texto": "Garantir que estamos com o MCP da Mastra nessa task pra ver a documentação pra cria um agente que faça sentido pra task",
          "concluido": false
        }
      ],
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:44:50-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T03:43:04.068-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:43:04-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T20:57:38.970-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T20:57:42.929-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T20:57:48.832-03:00"
        }
      ],
      "dataInicio": "2025-12-05T03:43:04.068-03:00",
      "dataFinalizacao": "2025-12-05T20:57:38.970-03:00"
    },
    {
      "id": "t9087",
      "descricao": "Tool que navega nas pastas (com node)",
      "detalhes": "algo similar ao que o claude code.. pq imagina que um agente que ok, tem contexto do nosso projeto, mas ele poderia navegar nas nossas pastas pra realmente entender e, assim, planejar a parada, sabe?",
      "dataCriacao": "2025-12-04T23:55:39-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T23:55:39-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:37:52-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T03:41:12.308-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:41:12-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T20:57:47.888-03:00"
        }
      ],
      "milestone": "m3",
      "dataInicio": "2025-12-05T03:41:12.308-03:00",
      "todos": [
        {
          "id": "td0230",
          "texto": "Validar se ta funfando!",
          "concluido": false
        }
      ],
      "dataFinalizacao": "2025-12-05T20:57:47.888-03:00"
    },
    {
      "id": "t9113",
      "descricao": "Ter um botão de \"plan\" em cada task",
      "milestone": "m3",
      "dataCriacao": "2025-12-04T01:32:39-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T01:32:39-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:45:11-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T03:41:08.815-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:41:08-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T20:57:27.788-03:00"
        }
      ],
      "detalhes": "A ideia é que a gente tenha um botão de plan, que ela vai olhar pro conteúdo da task, entender nosso projeto (pode ser por meio do nosso doc, ou entender com mastra como podemos \"navegar\" no nosso codigo, n sei, pra ela planejar a task, sabe?",
      "todos": [
        {
          "id": "td2186",
          "texto": "Usar MCP Mastra",
          "concluido": false
        }
      ],
      "dataInicio": "2025-12-05T03:41:08.815-03:00",
      "dataFinalizacao": "2025-12-05T20:57:27.788-03:00"
    },
    {
      "id": "t1044",
      "descricao": "Opção de criar task \"com ajuda da IA\"",
      "detalhes": "A ideia é que você possa falar o que quer, ele vai ver seu projeto e vai te sugerir uma task ja com os todos e passos",
      "milestone": "m3",
      "dataCriacao": "2025-12-04T23:13:41-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T23:13:41-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:45:26-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:21:03-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:30:05-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T20:57:26.364-03:00"
        }
      ],
      "dataInicio": "2025-12-05T00:21:03-03:00",
      "dataFinalizacao": "2025-12-05T20:57:26.364-03:00"
    },
    {
      "id": "t1009",
      "descricao": "precisamos ter uma estrutura de agentes, usando um pouco da t1005, onde temos um agente olha do pra tudo pra atualizar as coisas, um (pra esse projeto em especial), precisa ter um agente que vai olhar pra ca e manter esse guia llm atualizado",
      "detalhes": "",
      "milestone": "m3",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:44:41-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T23:44:45-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:47:56-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:30:05-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T00:30:10-03:00"
        }
      ],
      "dataFinalizacao": "2025-12-05T00:30:02-03:00"
    },
    {
      "id": "t8029",
      "descricao": "Ter opção de excluir uma task",
      "milestone": "m6021",
      "dataCriacao": "2025-12-04T01:19:18-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T01:19:18-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T22:28:50-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T23:30:35-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-04T23:36:15-03:00"
        }
      ],
      "dataInicio": "2025-12-04T23:30:35-03:00",
      "dataFinalizacao": "2025-12-04T23:36:15-03:00"
    },
    {
      "id": "t1004",
      "descricao": "ter um agente que é capaz de, baseado na task atual, criar um prompt pro agente ir fazendo - tipo, você clica na task, ele vai ler o titulo e tudo mais, vai ler o conteudo, e, baseado nisso, nos objetivos status e mais, ele vai criar um prompt pra você \"continuar\" essa task",
      "milestone": "m3",
      "detalhes": "- Esse agente precisa ter o contexto do projeto pra fazer isso\n- Ele pode ir perguntando mais, com base no titulo e detalhes pra garantir que realmente entendeu e etc",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:43:56-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:30:05-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T00:30:07-03:00"
        }
      ],
      "dataFinalizacao": "2025-12-05T00:30:00-03:00"
    },
    {
      "id": "t0008",
      "descricao": "Novo menu de \"gestão de agentes\"",
      "milestone": "m3",
      "dataCriacao": "2025-12-05T00:19:50-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:19:50-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T20:31:59.259-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T20:56:51.512-03:00"
        }
      ],
      "detalhes": "Nesse menu, colocar os agentes que temos, as tools, etc... dar uma visão geral a principio, e depois poder criar coisas sabe \n\nClaro! Vou te explicar toda a arquitetura que construímos:\n\n  📐 Arquitetura Geral\n\n  ┌─────────────────────────────────────────────────────────────┐\n  │                        FRONTEND (React)                      │\n  ├─────────────────────────────────────────────────────────────┤\n  │  • TaskCard (botões 🚀 e 🪄)                                │\n  │  • AITaskCreatorDialog (chat interface)                     │\n  │  • App.tsx (botão \"Criar com IA\")                           │\n  └──────────────────┬──────────────────────────────────────────┘\n                     │ HTTP requests\n  ┌──────────────────▼──────────────────────────────────────────┐\n  │                    BACKEND (Express)                         │\n  ├─────────────────────────────────────────────────────────────┤\n  │  4 Endpoints:                                                │\n  │  • POST /agents/generate-prompt                             │\n  │  • POST /agents/enrich-task                                 │\n  │  • POST /agents/create-task/chat                            │\n  │  • POST /agents/create-task/finalize                        │\n  └──────────────────┬──────────────────────────────────────────┘\n                     │ chama agentes\n  ┌──────────────────▼──────────────────────────────────────────┐\n  │                    MASTRA (AI Layer)                         │\n  ├─────────────────────────────────────────────────────────────┤\n  │  3 Agentes + 4 Tools compartilhadas                         │\n  └─────────────────────────────────────────────────────────────┘\n\n  ---\n  🤖 Os 3 Agentes\n\n  1. Prompt Generator Agent (mastra/agents/prompt-generator-agent.js)\n\n  O que faz: Gera um prompt markdown completo para você copiar e colar em outra LLM para continuar trabalhando na task.\n\n  Quando usar: Quando você quer delegar uma task para outro agente/pessoa mas precisa dar todo o contexto.\n\n  Botão: 🚀 (azul) no TaskCard\n\n  Fluxo:\n  Usuário clica 🚀\n    → Frontend chama /agents/generate-prompt\n      → Backend chama tools:\n        - readProjectFiles (contexto, status, guia)\n        - readTask (task atual + tasks relacionadas)\n        - readMilestones (milestones disponíveis)\n        - listProjectStructure (estrutura de pastas)\n      → Monta prompt gigante com tudo\n      → Agente gera prompt markdown estruturado\n    → Copia para clipboard\n    → Toast: \"🚀 Prompt copiado!\"\n\n  Exemplo de output:\n  # Task: Implementar botão de export CSV\n\n  ## Contexto do Projeto\n  [projeto-context.md completo aqui]\n\n  ## Status Atual\n  [status.md completo aqui]\n\n  ## Task Atual\n  - ID: t1234\n  - Descrição: Adicionar botão para exportar...\n  - Milestone: mvp\n  - To-dos:\n    1. Criar componente ExportButton\n    2. Implementar lógica de conversão\n\n  ## Próximos Passos\n  ...\n\n  ---\n  2. Task Enricher Agent (mastra/agents/task-enricher-agent.js)\n\n  O que faz: Pega uma task existente e melhora ela com base no contexto do projeto (descrição mais clara, detalhes\n  técnicos, to-dos estruturados, milestone sugerido).\n\n  Quando usar: Quando você criou uma task genérica/simples e quer que o agente deixe ela mais completa e técnica.\n\n  Botão: 🪄 (roxo) no TaskCard\n\n  Fluxo:\n  Usuário clica 🪄\n    → Frontend chama /agents/enrich-task\n      → Backend chama tools:\n        - readProjectFiles (contexto + guia de como escrever tasks)\n        - readTask (task atual + tasks do mesmo milestone para aprender o padrão)\n        - readMilestones (milestones disponíveis)\n      → Agente analisa e reestrutura\n      → Retorna JSON estruturado:\n        {\n          descricao: \"Descrição melhorada\",\n          detalhes: \"## Requisitos\\n...\",\n          todos: [{texto: \"...\"}, ...],\n          milestone: \"m1234\"\n        }\n    → Frontend atualiza a task com os dados melhorados\n    → Toast: \"✨ Task enriquecida!\"\n\n  Antes vs Depois:\n  ANTES:\n  - Descrição: \"adicionar export\"\n  - Detalhes: -\n  - To-dos: -\n\n  DEPOIS:\n  - Descrição: \"Implementar exportação de relatórios em CSV com filtros personalizados\"\n  - Detalhes: \"## Requisitos\\n- Botão no header...\\n## Implementação\\n...\"\n  - To-dos:\n    1. Criar componente ExportButton com ícone download\n    2. Implementar hook useExportCSV para conversão de dados\n    3. Adicionar loading state durante exportação\n    4. Testar com datasets grandes (>1000 linhas)\n  - Milestone: mvp\n\n  ---\n  3. Task Creator Agent (mastra/agents/task-creator-agent.js)\n\n  O que faz: Chat conversacional que te ajuda a criar uma task do zero fazendo perguntas estratégicas (2-4 perguntas no\n   máximo).\n\n  Quando usar: Quando você quer criar uma task nova mas não sabe exatamente como estruturar.\n\n  Botão: ✨ \"Criar com IA\" (roxo) no header do App\n\n  Fluxo:\n  Usuário clica \"Criar com IA\"\n    → Abre AITaskCreatorDialog (chat interface)\n    → Usuário digita: \"quero adicionar modo escuro\"\n\n    → Frontend chama /agents/create-task/chat\n      → Backend (primeira mensagem):\n        - readProjectFiles (contexto)\n        - readMilestones (milestones disponíveis)\n        - Adiciona context como system message\n        - Adiciona mensagem do usuário\n        - Agente responde: \"Legal! Isso é pro frontend (React), backend, ou ambos?\"\n      → Retorna: { message: \"...\", conversationHistory: [...] }\n\n    → Usuário: \"frontend, React\"\n    → Frontend chama /agents/create-task/chat novamente\n      → Backend envia histórico completo (system + user + assistant + user)\n      → Agente: \"Ótimo! Quer usar Context API ou alguma lib tipo zustand?\"\n\n    → Usuário: \"context api\"\n    → Agente: \"Perfeito! Em qual milestone? [lista os disponíveis]\"\n\n    → Usuário: \"mvp\"\n    → Agente: \"Show! Vou criar a task...\"\n\n    → Usuário clica \"Criar Task\"\n    → Frontend chama /agents/create-task/finalize\n      → Backend:\n        - Pega conversationHistory completo\n        - Adiciona mensagem final: \"crie a task estruturada\"\n        - Usa structuredOutput (JSON schema)\n        - Retorna: { task: {...} }\n\n    → Preview da task aparece\n    → Usuário clica \"Confirmar e Adicionar\"\n    → Task vai pro backlog\n\n  Características importantes:\n  - Stateless: Zero banco de dados! O histórico fica no estado do React\n  - Eficiente: Máximo 4 perguntas (instruções do agente)\n  - Contextual: Primeira mensagem já vem com projeto-context.md e milestones\n  - Conversação descartável: Quando fecha o dialog, histórico é limpo\n\n  ---\n  🛠️ As 4 Tools Compartilhadas\n\n  Todas as tools são usadas pelos agentes para buscar informações do projeto:\n\n  1. readProjectFiles (mastra/tools/read-project-files.js)\n\n  Input: { projectPath }Output: { projetoContext, status, llmGuide }O que faz: Lê os 3 arquivos markdown do projeto:\n  - projeto-context.md - Contexto geral do projeto\n  - status.md - Status atual do desenvolvimento\n  - llm-guide.md - Guia de como escrever tasks\n\n  ---\n  2. readTask (mastra/tools/read-task.js)\n\n  Input: { projectPath, taskId }Output: { task, relatedTasks }O que faz:\n  - Busca a task específica no tasks.json\n  - Busca outras tasks do mesmo milestone (para o agente aprender o padrão)\n\n  ---\n  3. readMilestones (mastra/tools/read-milestones.js)\n\n  Input: { projectPath }Output: { milestones: [{id, titulo, descricao, cor}, ...] }O que faz: Lista todos os milestones\n   disponíveis no projeto\n\n  ---\n  4. listProjectStructure (mastra/tools/list-project-structure.js)\n\n  Input: { projectPath }Output: { structure: \"string com árvore de pastas\", mainFolders: {...} }O que faz:\n  - Lista recursivamente as pastas do projeto (max depth 3)\n  - Ignora node_modules, .git, dist, etc\n  - Detecta se tem frontend/, backend/, client/, server/\n\n  ---\n  🎨 Interface (Frontend)\n\n  TaskCard.tsx - 2 novos botões\n\n  // Botão 1: Gerar Prompt (azul)\n  <Button onClick={handleGeneratePrompt}>\n    <Rocket className=\"h-4 w-4\" />\n  </Button>\n\n  // Botão 2: Enriquecer Task (roxo)\n  <Button onClick={handleEnrichTask}>\n    <Wand2 className=\"h-4 w-4\" />\n  </Button>\n\n  AITaskCreatorDialog.tsx - Chat completo\n\n  - Estado: messages (UI), conversationHistory (backend)\n  - Input + botão Send\n  - Lista de mensagens (user azul, assistant cinza)\n  - Botão \"Criar Task\" (quando tem 3+ mensagens)\n  - Preview da task criada (card verde)\n  - Botão \"Confirmar e Adicionar\"\n\n  App.tsx - Botão header\n\n  // Só aparece na view kanban\n  {activeView === 'kanban' && (\n    <Button onClick={() => setIsAIDialogOpen(true)}>\n      <Sparkles /> Criar com IA\n    </Button>\n  )}\n\n  ---\n  📊 Resumo Visual\n\n  ┌─────────────────────────────────────────────────────────────┐\n  │                      3 AGENTES                               │\n  ├─────────────────────────────────────────────────────────────┤\n  │                                                              │\n  │  1. Prompt Generator (🚀)                                   │\n  │     • Tools: ALL 4                                          │\n  │     • Output: Markdown gigante                              │\n  │     • Uso: Copiar prompt pra outra LLM                      │\n  │                                                              │\n  │  2. Task Enricher (🪄)                                      │\n  │     • Tools: readProjectFiles, readTask, readMilestones    │\n  │     • Output: JSON estruturado                              │\n  │     • Uso: Melhorar task existente                          │\n  │                                                              │\n  │  3. Task Creator (✨)                                       │\n  │     • Tools: readProjectFiles, readMilestones (1ª msg)     │\n  │     • Output: Conversa → JSON estruturado                   │\n  │     • Uso: Criar task do zero via chat                      │\n  │                                                              │\n  └─────────────────────────────────────────────────────────────┘\n            ▲                    ▲                    ▲\n            │                    │                    │\n       ┌────┴────┐         ┌─────┴─────┐       ┌─────┴─────┐\n       │  Tool1  │         │   Tool2   │       │   Tool3   │\n       │ Project │         │   Task    │       │ Milestones│\n       │  Files  │         │           │       │           │\n       └─────────┘         └───────────┘       └───────────┘\n                                 │\n                           ┌─────┴─────┐\n                           │   Tool4   │\n                           │ Structure │\n                           └───────────┘\n\n  ---\n  🎯 Decisões de Design\n\n  1. Zero Banco de Dados: Histórico de chat fica no frontend (React state), não usa LibSQL\n  2. Tools Compartilhadas: Todos os agentes usam as mesmas tools para evitar duplicação\n  3. Structured Output: Task Enricher e Task Creator usam JSON Schema para garantir formato correto\n  4. Logs Detalhados: Todos os endpoints logam cada etapa (📖 📋 🤖 ✅)\n  5. Conversas Descartáveis: Chat do Task Creator não persiste (fecha dialog = limpa tudo)\n  6. Contextual First Message: Task Creator já recebe projeto-context.md na primeira mensagem",
      "dataInicio": "2025-12-05T20:31:59.259-03:00",
      "dataFinalizacao": "2025-12-05T20:56:51.512-03:00"
    },
    {
      "id": "t8467",
      "descricao": "Ao copiar o path de uma task, incluir \"sobre o projeto\"",
      "milestone": "m6021",
      "detalhes": "Pode ser legal também tem algumas instruções, tipo:\n\n- Marcar a task como \"done\", \"criar mensagem de commit\", etc...\n- Atualizar \"o que for feito\", ao finalizar a task",
      "timeline": [
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T23:20:24-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-04T23:29:48-03:00"
        }
      ],
      "dataInicio": "2025-12-04T23:20:24-03:00",
      "dataFinalizacao": "2025-12-04T23:29:48-03:00"
    },
    {
      "id": "t3652",
      "descricao": "Ter uma \"timeline\" de tasks com os to-dos, backlogs e etc com as datinhas",
      "detalhes": "A ideia é que a gente possa ver quantas tasks fizemos, as que estào a fezer, quando incluimos ela, etc.. não sei bem como fazer e se é uma boa ideia, pedir opinicão LLM\n\nA ideia principal aqui é ter as task feitas em data X ou Y, ou em todo, etc..",
      "milestone": "m8738",
      "dataCriacao": "2025-12-04T01:27:13-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T01:27:13-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T01:28:17-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T23:20:29-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T23:20:36-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-04T23:26:18-03:00"
        }
      ],
      "dataInicio": "2025-12-04T23:20:29-03:00",
      "dataFinalizacao": "2025-12-04T23:26:18-03:00"
    },
    {
      "id": "t1042",
      "descricao": "Implementar uma barra lateral shadcn pra agregar as coisas",
      "milestone": "m2",
      "dataCriacao": "2025-12-04T22:31:11-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T22:31:11-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T22:33:52-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T22:34:33-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-04T23:17:17-03:00"
        }
      ],
      "dataInicio": "2025-12-04T22:34:33-03:00",
      "dataFinalizacao": "2025-12-04T23:17:17-03:00"
    },
    {
      "id": "t3674",
      "descricao": "Opção de excluir uma milestone",
      "milestone": "m8738",
      "dataCriacao": "2025-12-04T01:27:33-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T01:27:33-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T01:27:35-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T22:33:36-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-04T22:34:26-03:00"
        }
      ],
      "dataInicio": "2025-12-04T22:33:36-03:00",
      "dataFinalizacao": "2025-12-04T22:34:26-03:00"
    },
    {
      "id": "t3300",
      "descricao": "Ter um campo com \"o que foi feito\" (diferente do detalhes)",
      "milestone": "m6021",
      "detalhes": "Simplificado para ter apenas 2 campos:\n- detalhes (orientação do que precisa fazer)\n- resultado (o que foi feito ao finalizar)",
      "resultado": "✅ Campo 'resultado' implementado com sucesso\n✅ UI com Collapsible (collapse) no modal de detalhes\n✅ Aparece abaixo da seção de to-dos\n✅ Placeholder explicativo para guiar preenchimento\n✅ Salvamento integrado com os outros campos\n\nArquivos modificados:\n- client/src/types.ts - adicionado campo resultado\n- client/src/components/TaskCard.tsx - UI com Collapsible\n- kanban-live/llm-guide.md - documentação atualizada\n- kanban-live/projeto-context.md - schema e exemplos atualizados\n\nComponentes instalados:\n- @radix-ui/react-collapsible (via shadcn CLI)",
      "timeline": [
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T01:16:51-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-04T01:25:36-03:00"
        }
      ],
      "dataInicio": "2025-12-04T01:16:51-03:00",
      "dataFinalizacao": "2025-12-04T01:25:36-03:00"
    },
    {
      "id": "t1350",
      "descricao": "Ter um menu de busca",
      "milestone": "m1",
      "detalhes": "Simplesmente uma lupinha onde a gente busca algumas tasks e filtra elas no kanban, coisa fina! pode ficar do lado do menu de filtro! ao clicar, abre um menuzinho de busca, minimalista, ao digitar, filtra \"ao vivo\"",
      "timeline": [
        {
          "coluna": "doing",
          "timestamp": "2025-12-04T01:08:28-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-04T01:14:27-03:00"
        }
      ],
      "dataInicio": "2025-12-04T01:08:28-03:00",
      "dataFinalizacao": "2025-12-04T01:14:27-03:00"
    },
    {
      "id": "t4056",
      "descricao": "Garantir atualização em tempo real das tasks no front-end: quando um agente edita/atualiza uma task, as mudanças devem aparecer imediatamente",
      "milestone": "m1",
      "timeline": [
        {
          "coluna": "todo",
          "timestamp": "2025-12-04T23:45:01-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T03:43:16.619-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T00:43:16-03:00"
        }
      ],
      "dataFinalizacao": "2025-12-05T03:43:16.619-03:00"
    },
    {
      "id": "t6200",
      "descricao": "Incluir data nas tasks (data de começo > ter os updates > data de finalizacao)",
      "detalhes": "- pra isso, vamos precisar atualizar o json de tasks e o llm-guide, pra deixar claro pro agente os pontos e tals!\n- Pode ser legal ter tipo uma \"mini timeline\" de quando começou, etc, sabe? ... idealmente a gente tem essa timeline com \"momentos\" da task, pq nem sempre vamos conseguir finalizar ela de uma vez né?\n- Sempre que mover a taks pra algum dos kanbans, anotar de forma automatica (horario de SP!)",
      "milestone": "m6021",
      "timeline": [
        {
          "coluna": "done",
          "timestamp": "2025-12-04T01:05:51-03:00"
        }
      ],
      "dataFinalizacao": "2025-12-04T01:05:51-03:00"
    },
    {
      "id": "t1003",
      "descricao": "dentro das tasks, precisamos ter os \"to-do\", pra caso o agente não finalize nessa sessão, ficou claro oq foi feito e o que precis fazer ainda pro proximo agente",
      "milestone": "m6021",
      "detalhes": "",
      "todos": [
        {
          "id": "td7968",
          "texto": "Quando tiver to-do, aparecer como \"ver detalhes\"",
          "concluido": true
        }
      ]
    },
    {
      "id": "t1112",
      "descricao": "Ao copiar Objetivo & Status e Guia LLM, incluir path do projeto",
      "detalhes": "## O que era pra ser feito:\n- Quando copiar conteúdo das abas \"Objetivo & Status\" ou \"Guia LLM\", incluir o path do projeto no início\n- Facilitar para LLMs identificarem de qual projeto é o conteúdo\n\n## O que foi feito:\n\n### 1. Atualizado CopyButton para aceitar projectPath ✅\n**Arquivo:** `client/src/components/CopyButton.tsx`\n\n**Mudanças:**\n```typescript\ninterface CopyButtonProps {\n  content: string;\n  label?: string;\n  projectPath?: string; // NOVO - Path do projeto\n}\n\nconst handleCopy = async () => {\n  // Se tem projectPath, adiciona no início\n  const finalContent = projectPath\n    ? `Projeto: ${projectPath}\\n\\n---\\n\\n${content}`\n    : content;\n\n  await navigator.clipboard.writeText(finalContent);\n  // ...\n};\n```\n\n### 2. Atualizado App.tsx para passar projectPath ✅\n**Arquivo:** `client/src/App.tsx`\n\n**Status.md:**\n```tsx\n<CopyButton content={boardData.status} projectPath={boardData.projectPath} />\n```\n\n**Projeto-Context.md:**\n```tsx\n<CopyButton content={boardData.projetoContext} projectPath={boardData.projectPath} />\n```\n\n**LLM-Guide.md:**\n```tsx\n<CopyButton content={boardData.llmGuide} projectPath={boardData.projectPath} />\n```\n\n## Formato do conteúdo copiado:\n\n**Antes:**\n```\n# Status do Projeto\n...\n```\n\n**Depois:**\n```\nProjeto: /Users/nome/projeto/kanban-live\n\n---\n\n# Status do Projeto\n...\n```\n\n## Benefícios:\n✅ LLMs sabem imediatamente de qual projeto é o conteúdo\n✅ Evita confusão quando trabalhando com múltiplos projetos\n✅ Path completo com `/kanban-live/` sempre correto\n✅ Separador visual (`---`) deixa claro onde começa o conteúdo\n✅ Contagem de tokens inclui o path (mais preciso)\n\n## Arquivos modificados:\n- `client/src/components/CopyButton.tsx` - aceita `projectPath` opcional\n- `client/src/App.tsx` - passa `boardData.projectPath` para os 3 CopyButtons"
    },
    {
      "id": "t3434",
      "descricao": "Corrigir paths copiados para sempre incluir /kanban-live/ e nomes corretos nos recentes",
      "detalhes": "## O que era pra ser feito:\n- Quando copiar path de uma task, SEMPRE deve vir com `/kanban-live/` incluído\n- Sistema deve SEMPRE trabalhar dentro de `/kanban-live/`, sem fallback para raiz\n- Nomes dos projetos nos recentes devem mostrar o nome do projeto (não \"kanban-live\")\n- Evitar duplicação de `/kanban-live/kanban-live/`\n\n## O que foi feito:\n\n### 1. Backend - Path unificado sempre com /kanban-live/ ✅\n**Arquivo:** `backend/server.js` (GET /api/board)\n\n**Antes (PROBLEMA):**\n- Fazia fallback para raiz se não encontrasse `/kanban-live/`\n- Permitia projetos funcionarem sem a estrutura correta\n- Causava confusão de paths (com e sem `/kanban-live/`)\n\n**Depois (CORRIGIDO):**\n```javascript\n// Se o path já termina com /kanban-live, usa direto. Senão, adiciona /kanban-live\nlet basePath = projectPath;\nif (!projectPath.endsWith('kanban-live')) {\n  basePath = path.join(projectPath, 'kanban-live');\n}\n\n// Verifica se a pasta existe\ntry {\n  await fs.access(basePath);\n} catch {\n  // Se não existe, retorna mensagem pedindo Setup\n  return res.json({\n    status: '# Status\\n\\n(Arquivo não encontrado - clique em \"Setup Projeto\")',\n    tasks: { backlog: [], todo: [], doing: [], done: [] },\n    projectPath: basePath\n  });\n}\n```\n\n**Benefícios:**\n- ✅ SEMPRE retorna `projectPath` com `/kanban-live/` incluído\n- ✅ Não duplica se já vier com `/kanban-live/`\n- ✅ Obriga criação da estrutura correta (botão Setup)\n- ✅ Frontend sempre recebe path completo\n\n### 2. Frontend - Usa path retornado pelo backend ✅\n**Arquivo:** `client/src/contexts/BoardContext.tsx`\n\n**Antes (PROBLEMA):**\n```typescript\nconst data = await api.loadBoard(path);\nsetBoardData(data);\nlocalStorage.setItem('lastProjectPath', path); // Salvava path ORIGINAL ❌\n```\n\n**Depois (CORRIGIDO):**\n```typescript\nconst data = await api.loadBoard(path);\nsetBoardData(data);\n// Salva o path REAL retornado pelo backend (com /kanban-live/)\nlocalStorage.setItem('lastProjectPath', data.projectPath);\nreturn data; // Retorna para o Header usar\n```\n\n**Arquivo:** `client/src/components/Header.tsx`\n```typescript\nconst data = await loadProject(finalPath);\n// Salva nos recentes usando o path REAL retornado\nawait api.addRecentProject(data.projectPath);\n```\n\n### 3. Backend - Nomes corretos nos recentes ✅\n**Arquivo:** `backend/server.js` (POST /api/utils/add-recent-project)\n\n**Antes (PROBLEMA):**\n```javascript\nname: projectName || path.basename(projectPath)\n// Se projectPath = /projeto/kanban-live → name = \"kanban-live\" ❌\n```\n\n**Depois (CORRIGIDO):**\n```javascript\nlet finalProjectName = projectName;\nif (!finalProjectName) {\n  if (projectPath.endsWith('kanban-live')) {\n    // Pega o nome da pasta pai\n    // Ex: /path/to/test-llm/kanban-live → test-llm ✅\n    finalProjectName = path.basename(path.dirname(projectPath));\n  } else {\n    finalProjectName = path.basename(projectPath);\n  }\n}\n```\n\n### 4. Simplificação de endpoints ✅\n**Arquivos:** `backend/server.js`\n\n**Antes:** POST /api/board/tasks e POST /api/board/status faziam detecção de `/kanban-live/`\n\n**Depois:** Simplificados porque `projectPath` JÁ VEM com `/kanban-live/` do frontend\n```javascript\n// POST /api/board/tasks\nconst tasksFile = path.join(projectPath, 'tasks.json');\nawait fs.writeFile(tasksFile, JSON.stringify(tasks, null, 2), 'utf8');\n\n// POST /api/board/status  \nconst statusFile = path.join(projectPath, 'status.md');\nawait fs.writeFile(statusFile, content, 'utf8');\n```\n\n## Arquivos modificados:\n- `backend/server.js`\n  - GET /api/board - detecção inteligente com `.endsWith('kanban-live')`\n  - POST /api/board/tasks - simplificado (usa path direto)\n  - POST /api/board/status - simplificado (usa path direto)\n  - POST /api/utils/add-recent-project - extrai nome da pasta pai\n- `client/src/contexts/BoardContext.tsx`\n  - loadProject() agora retorna BoardData\n  - Salva path real no localStorage\n- `client/src/components/Header.tsx`\n  - Usa path retornado ao salvar nos recentes\n\n## Fluxo completo (ANTES vs DEPOIS):\n\n### ANTES (COM PROBLEMAS):\n1. Usuário cola: `/Users/nome/test-llm`\n2. Backend detecta: `/Users/nome/test-llm/kanban-live/`\n3. ❌ Mas salvava nos recentes: `/Users/nome/test-llm`\n4. ❌ Nome aparecia: \"test-llm\"\n5. ❌ Ao copiar task: `/Users/nome/test-llm/tasks.json#t1234`\n\n### DEPOIS (FUNCIONANDO):\n1. Usuário cola: `/Users/nome/test-llm` (com ou sem `/kanban-live/`)\n2. Backend detecta: `/Users/nome/test-llm/kanban-live/`\n3. ✅ Retorna: `projectPath: \"/Users/nome/test-llm/kanban-live\"`\n4. ✅ Salva nos recentes: `/Users/nome/test-llm/kanban-live`\n5. ✅ Nome extraído: \"test-llm\" (pasta pai)\n6. ✅ Ao copiar task: `/Users/nome/test-llm/kanban-live/tasks.json#t1234`\n7. ✅ Ao criar/editar: salva em `/Users/nome/test-llm/kanban-live/tasks.json`\n\n## Resultados:\n✅ Paths sempre corretos e consistentes\n✅ Não importa se cola com ou sem `/kanban-live/`\n✅ Nomes dos projetos aparecem corretamente\n✅ Sem duplicação de `/kanban-live/kanban-live/`\n✅ Sistema sempre trabalha dentro de `/kanban-live/`\n✅ Projetos sem estrutura mostram botão Setup\n✅ Tudo funciona de forma transparente para o usuário"
    },
    {
      "id": "t0374",
      "descricao": "Salvar últimos projetos acessados e renomear example-project para kanban-live",
      "detalhes": "## O que era pra ser feito:\n- Renomear pasta `example-project` para `kanban-live`\n- Criar arquivo `utils.json` para salvar últimos projetos\n- Evitar copiar/colar paths toda hora\n- Atualizar referências no código e documentação\n- Atualizar llm-guide.md\n\n## O que foi feito:\n\n### 1. Renomeação da Pasta ✅\n- Renomeada pasta de `example-project` para `kanban-live`\n- Atualizado README.md com novo caminho\n- Atualizado projeto-context.md com nova estrutura\n\n### 2. Criado utils.json ✅\n**Arquivo:** `kanban-live/utils.json`\n**Estrutura:**\n```json\n{\n  \"recentProjects\": [\n    {\n      \"path\": \"/caminho/do/projeto\",\n      \"name\": \"nome-projeto\",\n      \"lastAccessed\": \"2025-11-13T00:00:00.000Z\"\n    }\n  ],\n  \"settings\": {\n    \"maxRecentProjects\": 5\n  }\n}\n```\n\n### 3. Backend - Novos Endpoints ✅\n**Arquivo:** `backend/server.js`\n\n**GET /api/utils/recent-projects**\n- Retorna lista de projetos recentes\n- Fallback para array vazio se arquivo não existe\n\n**POST /api/utils/add-recent-project**\n- Adiciona projeto à lista de recentes\n- Remove duplicatas (atualiza lastAccessed)\n- Limita a 5 projetos (configurável)\n- Ordena por mais recente primeiro\n\n**DELETE /api/utils/remove-recent-project**\n- Remove projeto específico da lista\n- Atualiza utils.json automaticamente\n\n### 4. Frontend - API e UI ✅\n**Arquivo:** `client/src/lib/api.ts`\n- Função `getRecentProjects()` - busca lista\n- Função `addRecentProject()` - adiciona à lista\n- Função `removeRecentProject()` - remove da lista\n\n**Arquivo:** `client/src/components/Header.tsx`\n- Dropdown \"Recentes\" com ícone de relógio\n- Lista mostra nome, path e data de acesso\n- Clique no projeto carrega automaticamente\n- **Ícone de lixeira** ao passar mouse (hover)\n- Remove projeto ao clicar na lixeira\n- Overlay para fechar dropdown ao clicar fora\n- Contador de projetos no botão\n\n### 5. Documentação Atualizada ✅\n**README.md:**\n- Atualizado de `example-project` para `kanban-live`\n- Exemplos de paths corrigidos\n\n**projeto-context.md:**\n- Estrutura de pastas atualizada\n- Adicionado `utils.json` na estrutura\n\n**llm-guide.md:**\n- Adicionado `utils.json` na tabela de arquivos\n- Nota explicando que é gerenciado automaticamente\n- Indicação de não editar manualmente\n\n## Arquivos criados:\n- `kanban-live/utils.json` - NOVO arquivo\n\n## Arquivos modificados:\n- `backend/server.js` - 3 novos endpoints\n- `client/src/lib/api.ts` - 3 novas funções\n- `client/src/components/Header.tsx` - dropdown de recentes + lixeira\n- `README.md` - referências atualizadas\n- `kanban-live/projeto-context.md` - estrutura atualizada\n- `kanban-live/llm-guide.md` - documentação do utils.json\n\n## Funcionalidades:\n✅ Salva últimos 5 projetos automaticamente\n✅ Dropdown mostra projetos com nome, path e data\n✅ Clique para carregar projeto rapidamente\n✅ Ícone de lixeira para remover recentes\n✅ Totalmente integrado com backend\n✅ Pasta renomeada para `kanban-live`\n✅ Documentação 100% atualizada"
    },
    {
      "id": "t3122",
      "descricao": "Exibir os detalhes das tasks em um modal/dialog responsivo em vez de no corpo da task para evitar conteúdo extenso",
      "detalhes": "## O que era pra ser feito:\n- Remover exibição inline dos detalhes que ocupava muito espaço no card\n- Usar o componente Dialog do shadcn/ui para exibir detalhes em modal\n- Manter funcionalidade de edição dos detalhes\n- Tornar a interface mais limpa e organizada\n\n## O que foi feito:\n✅ Removida exibição inline de detalhes que ocupava espaço no card\n✅ Implementado Dialog (modal) do shadcn/ui para exibir detalhes\n✅ Adicionado ícone FileText + link \"Ver detalhes\" quando task tem detalhes\n✅ Mantido botão \"+ Adicionar detalhes\" quando task não tem detalhes\n✅ Modal responsivo com max-width de 2xl e max-height de 80vh\n✅ Textarea com min-height de 200px para edição confortável\n✅ Botões \"Cancelar\" e \"Salvar\" no modal\n✅ Toast de feedback ao salvar detalhes\n✅ AutoFocus no textarea quando adicionando detalhes pela primeira vez\n✅ Título do modal mostra ID e descrição da task\n\n## Arquivos modificados:\n- client/src/components/TaskCard.tsx:\n  - Importado Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription\n  - Importado ícone FileText do lucide-react\n  - Substituído estado `showDetails` por `isDialogOpen`\n  - Adicionada função `handleSaveDetails()` para salvar e fechar modal\n  - Removida exibição inline dos detalhes (linhas 149-173 antigas)\n  - Adicionado link \"Ver detalhes\" com ícone quando task tem detalhes\n  - Implementado Dialog completo com header, textarea e botões\n  - Modal com scroll automático para conteúdos extensos\n\n## Benefícios:\n- Cards agora são muito mais compactos\n- Detalhes extensos não quebram o layout do Kanban\n- Melhor experiência de edição com modal focado\n- Interface mais limpa e profissional\n- Responsivo em diferentes tamanhos de tela"
    },
    {
      "id": "t4748",
      "descricao": "Integrar o Mastra AI Framework ao Live Kanban para orquestração de agentes — implementar SDK/cliente, configurar autenticação e endpoints",
      "detalhes": "## ✅ O que foi implementado:\n\n### 1. Estrutura Criada\n```\nlive-kanban/\n├── mastra/\n│   ├── agents/\n│   │   └── task-enhancer.js    # Agente para melhorar descrições\n│   ├── index.js                # Configuração Mastra\n│   ├── README.md               # Documentação\n│   └── MIGRATION.md            # Guia JS vs TS\n├── .env                        # Variáveis de ambiente\n└── .env.example                # Template de configuração\n```\n\n### 2. Dependências Instaladas\n✅ `@mastra/core@^0.24.0`\n✅ `@ai-sdk/openai@^2.0.65`\n✅ `zod@^3.25.76`\n✅ `dotenv@^17.2.3`\n\n### 3. Configuração de Ambiente\n**Arquivo `.env` criado com:**\n- `OPENAI_API_KEY` - Chave da OpenAI\n- `OPENAI_MODEL` - Modelo configurável (padrão: gpt-4o-mini)\n\n**Modelos suportados:**\n- gpt-5-mini ($0.25 input / $2.00 output)\n- gpt-5 ($1.25 input / $10.00 output)\n- gpt-5-nano ($0.05 input / $0.40 output)\n- gpt-5-codex ($1.25 input / $10.00 output)\n- gpt-4o-mini, gpt-4o, gpt-4-turbo\n\n### 4. Agente Task Enhancer\n**Arquivo:** `mastra/agents/task-enhancer.js`\n**Função:** Melhora descrições de tasks tornando-as mais claras e objetivas\n**Input:** Descrição da task (string)\n**Output:** Descrição melhorada (string)\n**Características:**\n- Carrega variáveis de ambiente do .env raiz\n- Modelo configurável via OPENAI_MODEL\n- Debug logging para API key\n- Instruções em português\n- Mantém tom profissional mas amigável\n\n### 5. Integração Backend\n**Arquivo modificado:** `backend/server.js`\n**Novo endpoint:** `POST /api/agents/enhance-task`\n**Recebe:** `{ taskDescription: string }`\n**Retorna:** `{ success: true, descricao: string }`\n**Implementação:**\n- Import dinâmico do Mastra (ES modules em projeto CommonJS)\n- Graceful degradation se Mastra não carregar\n- Tratamento de erros com logs\n- Resposta simplificada (apenas descrição melhorada)\n\n### 6. Integração Frontend\n**Arquivo modificado:** `client/src/lib/api.ts`\n**Nova função:** `enhanceTask(taskDescription: string): Promise<string>`\n\n**Arquivo modificado:** `client/src/components/TaskCard.tsx`\n**UI adicionada:**\n- Botão ✨ (Sparkles) em cada card\n- Loading state com spinner animado\n- Toast de sucesso/erro\n- Atualização automática da descrição no card\n- Título de ajuda ao hover\n\n### 7. Arquitetura JavaScript ES Modules\n**Decisão:** Usar JavaScript ao invés de TypeScript para Mastra\n**Vantagens:**\n- Mais simples (sem compilação TS)\n- Menos configuração\n- Mais rápido para prototipar\n- Node.js nativo\n- 100% compatível com API do Mastra\n\n**Configuração especial:**\n- `\"type\": \"module\"` no package.json raiz\n- dotenv.config com path absoluto para .env na raiz\n- Import dinâmico no backend CommonJS\n\n### 8. Correções Aplicadas\n✅ **Schema validation error** - Removido structured output, usando response.text direto\n✅ **dotenv path resolution** - Configurado path absoluto para .env\n✅ **Model configuration** - Modelo configurável via variável de ambiente\n✅ **API key loading** - Debug logs para verificar carregamento\n\n## 🎯 Como Usar\n\n1. **Configure o .env:**\n```bash\ncp .env.example .env\n# Edite .env com sua OPENAI_API_KEY\n```\n\n2. **Inicie o servidor:**\n```bash\nnpm start  # Backend + Frontend + Mastra\n```\n\n3. **No Kanban:**\n- Clique no ícone ✨ em qualquer card\n- Aguarde o processamento\n- A descrição será melhorada automaticamente\n\n## 📚 Documentação Criada\n\n✅ `mastra/README.md` - Guia completo de uso e adição de novos agentes\n✅ `mastra/MIGRATION.md` - Comparação JS vs TS e guia de migração\n✅ `.env.example` - Template com todos os modelos disponíveis\n\n## 🔮 Próximos Passos (Roadmap)\n\n- [ ] Prompt Generator Agent\n- [ ] Doc Updater Agent\n- [ ] Code Reviewer Agent\n- [ ] Test Generator Agent\n- [ ] Commit Message Generator Agent"
    },
    {
      "id": "t8119",
      "descricao": "Em todas as paginas, tem um botão de copiar e colocar a media de tokens que aquele texto que a pessoa ta copiando tem (ver como faz esse calculo de token)",
      "detalhes": "## O que era pra ser feito:\n- Adicionar botão de copiar em todas as páginas (Status, Contexto, Guia LLM)\n- Mostrar contagem aproximada de tokens do texto\n- Usar cálculo: 1 token ≈ 4 caracteres\n\n## O que foi feito:\n✅ Criado componente `CopyButton.tsx` com cálculo de tokens (1 token ≈ 4 caracteres)\n✅ Adicionado botão na aba \"Objetivo & Status\" para Status.md (~tokens)\n✅ Adicionado botão na aba \"Objetivo & Status\" para Projeto-Context.md (~tokens)\n✅ Adicionado botão na aba \"Guia LLM\" (~tokens)\n✅ Feedback visual com toast mostrando contagem de tokens ao copiar\n✅ Ícone de Check quando copiado com sucesso\n✅ Formatação brasileira de números (ex: 1.234 tokens)\n\n## Arquivos criados/modificados:\n- client/src/components/CopyButton.tsx - NOVO componente\n- client/src/App.tsx - adicionados 3 CopyButtons nas abas"
    },
    {
      "id": "t1001",
      "descricao": "em obj e status ter um documento vivo que explique toda a stack, como o projeto funciona e mais, para que a LLM possa consultar e entender o core da aplicação",
      "detalhes": "## O que era pra ser feito:\n- Criar documento que explique stack completa\n- Incluir arquitetura do projeto\n- Detalhar tecnologias usadas\n- Explicar como o projeto funciona\n- Servir como referência para LLMs\n\n## O que foi feito:\n✅ Criado arquivo `projeto-context.md` com 18 seções completas\n✅ Documentada stack completa (React 19, Tailwind v4, shadcn/ui, etc.)\n✅ Incluída estrutura de pastas e arquivos\n✅ Adicionadas regras de negócio e padrões de código\n✅ Documentados pontos críticos de atenção\n✅ Explicadas decisões arquiteturais\n✅ Adicionados exemplos de código\n✅ Incluído roadmap e próximos passos\n✅ Atualizado `llm-guide.md` para referenciar o novo arquivo\n\n## Arquivos criados/modificados:\n- example-project/projeto-context.md - NOVO arquivo com contexto completo\n- example-project/llm-guide.md - adicionada seção 0 referenciando projeto-context.md"
    },
    {
      "id": "t1007",
      "descricao": "usar shadcn - precisamos ter um backlog tb"
    },
    {
      "id": "t1006",
      "descricao": "os cards devem ser editaveis e, dentro deles, ter o texto de \"o que ta sendo feito e como\" - isso deve ser um padrao tb, no guia da LLM, pra gente seguir um padrão - cada task precisa ter um botaozinho de copiar, que copia o path pra ela tb!",
      "detalhes": "## O que era pra ser feito:\n- Cards editáveis com campo de detalhes\n- Campo para descrever \"o que está sendo feito e como\"\n- Botão de copiar que copia o path completo da task\n- Estabelecer padrão para guia LLM\n\n## O que foi feito:\n✅ Atualizado tipo Task para incluir campo opcional 'detalhes'\n✅ Implementado UI expandível nos cards (botão \"+ Adicionar detalhes\")\n✅ Edição inline com textarea para detalhes\n✅ Botão 📋 que copia path completo: /path/to/project/tasks.json#taskId\n✅ Adicionado Sonner (toast) para feedback visual ao copiar\n✅ Cursor pointer no botão de copiar\n✅ Desabilita drag quando está editando\n✅ Double-click para editar descrição e detalhes\n\n## Arquivos modificados:\n- client/src/types.ts - adicionado campo detalhes\n- client/src/components/TaskCard.tsx - UI expandível e botão copiar\n- client/src/components/KanbanColumn.tsx - passa projectPath\n- client/src/components/KanbanBoard.tsx - handleUpdateTask genérico\n- client/src/App.tsx - adicionado Toaster"
    },
    {
      "id": "t1002",
      "descricao": "ter um botao de \"setup no projeto\", onde a gente pega um projeto que não usa e inclui esse setup de pastas e etc - idealmente, a gente tem um agente acoplado que le o projeto e faz o objetivo e status tb",
      "detalhes": "## O que era pra ser feito:\n- Botão de \"Setup Projeto\" no Header\n- Detectar quando projeto não tem estrutura kanban-live/\n- Criar estrutura completa automaticamente:\n  - tasks.json (4 colunas: backlog, todo, doing, done)\n  - status.md (template inicial)\n  - projeto-context.md (template inicial)\n  - utils.json (configuração padrão)\n  - llm-guide.md (cópia do template)\n- Sistema funcionar com path do projeto raiz (ex: /projeto) detectando automaticamente /projeto/kanban-live/\n\n## O que foi feito:\n\n### 1. Backend - Endpoint POST /api/setup-project ✅\n**Arquivo:** `backend/server.js`\n**Funcionalidade:**\n- Recebe projectPath do usuário\n- Verifica se kanban-live/ já existe (retorna erro se sim)\n- Cria pasta kanban-live/ no projeto\n- Cria 5 arquivos com templates:\n  - `tasks.json` - estrutura vazia com 4 colunas\n  - `status.md` - template com data atual e seções padrão\n  - `projeto-context.md` - template com seções de stack e arquitetura\n  - `utils.json` - estrutura de projetos recentes vazia\n  - `llm-guide.md` - cópia completa do template do live-kanban\n- Retorna sucesso com lista de arquivos criados\n\n### 2. Backend - Detecção Automática de kanban-live/ ✅\n**Arquivos modificados:** `backend/server.js`\n**Endpoints atualizados:**\n- GET `/api/board` - detecta automaticamente se existe /projeto/kanban-live/\n- POST `/api/board/tasks` - salva no path correto (kanban-live/ ou raiz)\n- POST `/api/board/status` - salva no path correto (kanban-live/ ou raiz)\n\n**Lógica implementada:**\n```javascript\nlet basePath = projectPath;\nconst kanbanLivePath = path.join(projectPath, 'kanban-live');\n\ntry {\n  await fs.access(kanbanLivePath);\n  basePath = kanbanLivePath; // Usa kanban-live/ se existir\n} catch {\n  // Usa path direto (retrocompatibilidade)\n}\n```\n\n### 3. Frontend - API Client ✅\n**Arquivo:** `client/src/lib/api.ts`\n**Nova função adicionada:**\n```typescript\nasync setupProject(projectPath: string): Promise<{ \n  success: boolean; \n  message: string; \n  files: string[] \n}>\n```\n\n### 4. Frontend - Botão Setup no Header ✅\n**Arquivo:** `client/src/components/Header.tsx`\n**Funcionalidades:**\n- Importado ícone Settings do lucide-react\n- Importado toast do sonner para feedback\n- Detecta quando projeto não tem estrutura: `needsSetup = boardData.status.includes('(Arquivo não encontrado)')`\n- Botão \"Setup Projeto\" aparece condicionalmente quando needsSetup === true\n- Estado `settingUp` para loading durante criação\n- Ao clicar:\n  1. Valida se projectPath está preenchido\n  2. Chama api.setupProject()\n  3. Mostra toast de sucesso com lista de arquivos criados\n  4. Aguarda 1 segundo\n  5. Carrega o projeto automaticamente\n- Botão azul destacado (bg-blue-600) para chamar atenção\n- Desabilitado durante criação (\"Criando...\")\n\n### 5. Retrocompatibilidade ✅\n**Sistema funciona em 2 cenários:**\n\n**Cenário 1: Projeto com kanban-live/**\n- Usuário cola: `/Users/nome/projeto`\n- Sistema busca automaticamente em: `/Users/nome/projeto/kanban-live/`\n- Tudo funciona normalmente\n\n**Cenário 2: Projeto legacy (sem kanban-live/)**\n- Usuário cola: `/Users/nome/projeto-antigo`\n- Sistema busca em: `/Users/nome/projeto-antigo/` (raiz)\n- Mantém compatibilidade com projetos antigos\n\n## Arquivos criados/modificados:\n\n**Backend:**\n- `backend/server.js` - novo endpoint setup-project + detecção automática em 3 endpoints\n\n**Frontend:**\n- `client/src/lib/api.ts` - função setupProject()\n- `client/src/components/Header.tsx` - botão Setup + lógica de detecção\n\n## Benefícios:\n\n✅ Usuário não precisa criar estrutura manualmente\n✅ Um clique cria tudo automaticamente\n✅ Path unificado: sempre usa /projeto/ (detecta kanban-live/ automaticamente)\n✅ Feedback visual com toast\n✅ Carregamento automático após criação\n✅ Retrocompatível com projetos antigos\n✅ Templates prontos e bem estruturados\n✅ llm-guide.md copiado do template oficial\n\n## Fluxo de uso:\n\n1. Usuário cola path do projeto: `/Users/nome/novo-projeto`\n2. Clica em \"Carregar Projeto\"\n3. Sistema detecta que não tem estrutura\n4. Botão \"Setup Projeto\" aparece\n5. Usuário clica no botão\n6. Sistema cria pasta `kanban-live/` com todos os arquivos\n7. Toast mostra \"✅ Estrutura kanban-live criada com sucesso\"\n8. Toast mostra \"Arquivos criados: tasks.json, status.md, ...\"\n9. Projeto carrega automaticamente\n10. Pronto para usar! 🎉"
    },
    {
      "id": "t5226",
      "descricao": "Onde pega os recentes, ter a opção de buscar por um arquivo (como um buscador de arquivos mesmo)"
    },
    {
      "id": "t7870",
      "descricao": "Não ta rolando de colocar novos projetos, da erro!",
      "milestone": "m3875",
      "dataCriacao": "2025-12-09T20:49:27-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-09T20:49:27-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-12T02:44:31.636-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-12T15:17:36.242-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-12T15:17:37.283-03:00"
        }
      ],
      "dataFinalizacao": "2025-12-12T02:44:31.636-03:00",
      "dataInicio": "2025-12-12T15:17:36.242-03:00"
    },
    {
      "id": "t1398",
      "descricao": "Corrigir overflow de texto nos TaskCards: limitar linhas e ajustar menu/lixeira (UI/Tailwind)",
      "milestone": "m3875",
      "dataCriacao": "2025-12-04T23:47:01-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T23:47:01-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T12:00:00-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T03:40:11.785-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T03:40:16.300-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T00:40:16-03:00"
        }
      ],
      "detalhes": "O que precisa ser feito:\n\n- Reproduzir o problema localmente com a task `t1398` (descrições longas + menu de ações) para entender casos.\n- Limitar a altura/linhas da descrição do card (ex: 2–3 linhas) usando CSS (line-clamp) ou utilitários Tailwind; mostrar ellipsis.\n- Ajustar tamanho e espaçamento do menu de ações (ícones: lixeira, editar, mais) para não empurrar/expandir o card; usar tamanhos fixos (w-8 h-8) e flex container com gap.\n- Garantir que o card preserve acessibilidade (aria-labels) e que o conteúdo que foi truncado ainda seja acessível via modal \"Ver detalhes\".\n\nArquivos a modificar (prováveis):\n\n- client/src/components/TaskCard.tsx  — principal: clamp de texto, classes Tailwind, estrutura do menu/ícones, aria attributes\n- client/src/components/KanbanColumn.tsx — wrapper da coluna: overflow handling / max-width / padding se necessário\n- client/src/index.css (ou client/src/styles/*.css) — adicionar utilidade CSS para -webkit-line-clamp se for usada (evitar instalar plugins Tailwind)\n- client/src/components/ui/* (somente se o botão/menu for um componente shadcn customizado) — ajustar classes do componente\n- client/src/lib/utils.ts (opcional) — helper para gerar classes cn() se for útil\n\nObservações:\n\n- ⚠️ Não adicione plugins Tailwind não suportados pelo projeto; preferir utilidade CSS local para line-clamp (ex: .line-clamp-3 usando -webkit-line-clamp) ou usar classes existentes (overflow-hidden, text-ellipsis, break-words).\n- ⚠️ NÃO modifique componentes instalados via shadcn/ui manualmente sem usar o CLI se for criar novos componentes; ajustes de classes dentro dos componentes do projeto são aceitáveis.\n- ⚠️ Preserve import de tipos conforme padrão: import type { Task } from '@/types.js'.\n- ⚠️ Mantenha comportamentos existentes: truncar apenas visualmente — detalhes completos devem abrir no modal de detalhes (não remover dados do task.json).\n- ✅ Ao finalizar, documente nos detalhes da task quais arquivos foram alterados e inclua prints ou referência de QA (passos para reproduzir e validar).\n",
      "todos": [
        {
          "id": "td23238796",
          "texto": "Reproduzir bug localmente com a task t1398 e capturar 1 screenshot / steps para reproduzir",
          "concluido": true
        },
        {
          "id": "td23231510",
          "texto": "No client/src/components/TaskCard.tsx: limitar descrição a 2–3 linhas (usar classe .line-clamp-3 em CSS global ou inline), adicionar overflow-hidden, text-ellipsis e break-words",
          "concluido": true
        },
        {
          "id": "td23231249",
          "texto": "Reduzir footprint do menu/ícones: trocar classes para tamanhos fixos (ex: w-8 h-8 text-sm), agrupar botões em container flex com gap e min-width controlado",
          "concluido": true
        },
        {
          "id": "td23236462",
          "texto": "Ajustar KanbanColumn wrapper (client/src/components/KanbanColumn.tsx) para garantir que cards não ultrapassem a largura da coluna (max-w-full, overflow-hidden) e testar responsividade",
          "concluido": true
        },
        {
          "id": "td23235453",
          "texto": "Rodar QA manual: abrir board, testar várias tasks longas, navegar com teclado/abrir modal de detalhes para confirmar conteúdo completo, documentar mudanças em detalhes da task",
          "concluido": true
        }
      ],
      "dataFinalizacao": "2025-12-05T12:00:00-03:00",
      "resultado": "✅ Text overflow resolvido com \n-clamp-3 a descrição.\n✅ Footer do card reorganizado para melhor aproveitar o espaço.\n✅ Botões de ação movidos para o footer, alinhados à direita.\n✅ Layout do header simplificado (ID e badges).\n✅ Adicionado \n-x-hidden na coluna do Kanban para evitar scroll horizontal indesejado.\n\nArquivos modificados:\n- client/src/components/TaskCard.tsx\n- client/src/components/KanbanColumn.tsx",
      "dataInicio": "2025-12-05T03:40:11.785-03:00"
    },
    {
      "id": "t0066",
      "descricao": "Corrigir corrupção de task ao arrastar (DnD @hello-pangea/dnd + persistência Express/tasks.json)",
      "milestone": "m3875",
      "dataCriacao": "2025-12-04T23:46:30-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-04T23:46:30-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:33:05-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:34:49-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:34:53-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:34:56-03:00"
        },
        {
          "coluna": "todo",
          "timestamp": "2025-12-05T00:34:58-03:00"
        },
        {
          "coluna": "backlog",
          "timestamp": "2025-12-05T00:35:01-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:37:38-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T00:37:42-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T03:40:14.126-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-05T03:40:15.445-03:00"
        },
        {
          "coluna": "done",
          "timestamp": "2025-12-05T03:40:28.630Z"
        }
      ],
      "detalhes": "Ao mover um card, ele move outro, ta tudo cagado\n\nO que precisa ser feito:\n\n- Reproduzir e registrar (console, network) o fluxo de drag-and-drop que corrompe a task: mover entre colunas e reordenar dentro da mesma coluna.\n- Corrigir a lógica de onDragEnd/handleDragEnd no frontend para garantir updates imutáveis do estado, manutenção do schema do tasks.json (timeline, dataInicio, dataFinalizacao) e chamada correta à API de persistência.\n- Garantir que a atualização seja persistida de forma atômica no backend (server.js) e que o cliente trate erros (rollback/notification) sem deixar o UI inconsistente.\n- Verificar concorrência/escritas paralelas e aplicar lock simples ou await para evitar race conditions ao salvar tasks.json.\n\nArquivos a modificar (prováveis):\n\n- client/src/components/KanbanBoard.tsx  -- revisar handleDragEnd / DragDropContext\n- client/src/components/KanbanColumn.tsx -- revisar reorder helpers e keys\n- client/src/components/TaskCard.tsx     -- checar efeitos colaterais de render/re-render\n- client/src/contexts/BoardContext.tsx  -- garantir atualização imutável e funções updateTasks/saveBoard\n- client/src/lib/api.ts                  -- validar função que chama POST /api/board/tasks (payload completo)\n- client/src/types.ts                    -- (se necessário) validar tipos Task/TasksData\n- backend/server.js                      -- validar escrita atômica, validação JSON e resposta adequada\n- kanban-live/tasks.json                 -- usado apenas para testes/manuais (não commitar mudanças que quebrem o schema)\n\nObservações / requisitos técnicos:\n\n- Ao modificar tasks.json siga o padrão do projeto: usar Read antes de Edit, preservar fields: milestones, backlog, todo, doing, done.\n- Ao mover task:\n  - adicionar evento na timeline com timestamp no formato ISO com timezone São Paulo (-03:00) (use util existente para timezone ou manter padrão do projeto);\n  - setar dataInicio quando entrar em \"doing\" pela PRIMEIRA vez;\n  - setar dataFinalizacao quando entrar em \"done\" pela PRIMEIRA vez;\n  - nunca alterar IDs existentes.\n- Frontend: aplique updates imutáveis (ex: structuredClone / map/filter) e atualize o contexto via BoardContext.updateTasks; faça chamada API com o board completo (não enviar only-diff) e espere resposta antes de confirmar persistência; aplicar otimistic UI com rollback em erro.\n- Backend: salvar o arquivo de forma atômica (escrever em temp + rename) e retornar status claro; validar JSON e retornar erro detalhado em caso de falha.\n- Adicionar toasts (sonner) para sucesso/erro de salvamento e logs de console para debugging.\n\n⚠️ Warnings:\n- ⚠️ Não modifique manualmente o formato de tasks.json (campos obrigatórios/milestones).\n- ⚠️ Não alterar IDs existentes nem gerar IDs fora do padrão (t + 4 dígitos / td + 4 dígitos / m + 4 dígitos).\n- ⚠️ Evite usar componentes shadcn/ui manualmente sem rodar o CLI quando for adicionar UI; neste bug fix não é necessário.\n- ⚠️ Teste com polling do frontend (2s) e faça reload para validar persistência real no arquivo.\n\nCritérios de aceite:\n\n1. Reproduzível: steps para reproduzir documentados no ticket e logs anexados (console + network payload).\n2. UI consistente: após mover, card aparece na coluna correta sem duplicação nem corrupção de campos.\n3. Persistência: tasks.json atualizado corretamente (timeline + possíveis dataInicio/dataFinalizacao) e backend retorna sucesso.\n4. Sem regressões: drag-and-drop continua funcionando com edição inline e menu de to-dos ativados/desativados.\n\n",
      "todos": [
        {
          "id": "td87752841",
          "texto": "Reproduzir bug e coletar evidências: filmar/print do console, network (payload do PUT/POST), e o estado antes/depois no kanban-live/tasks.json",
          "concluido": true
        },
        {
          "id": "td87757128",
          "texto": "Revisar e corrigir handleDragEnd em client/src/components/KanbanBoard.tsx — garantir updates imutáveis, uso correto de source/destination e manutenção do timeline/dataInicio/dataFinalizacao",
          "concluido": true
        },
        {
          "id": "td87755252",
          "texto": "Atualizar BoardContext (client/src/contexts/BoardContext.tsx) para aplicar mudanças de forma atômica, oferecer rollback em erro e expor método saveBoard que chama client/src/lib/api.ts",
          "concluido": true
        },
        {
          "id": "td87758904",
          "texto": "Corrigir cliente HTTP em client/src/lib/api.ts para enviar o payload completo do board, tratar erros do backend e retornar resposta padronizada",
          "concluido": true
        },
        {
          "id": "td87758428",
          "texto": "Melhorar backend/server.js: validar JSON recebido, salvar tasks.json de forma atômica (temp file + rename) e prevenir escritas concorrentes (await/lock simples)",
          "concluido": true
        },
        {
          "id": "td87756936",
          "texto": "Adicionar notificações (sonner) para sucesso/erro de salvamento e adicionar logs de debug; testar manualmente cover cases (reordenar, mover entre colunas, mover de volta)",
          "concluido": true
        }
      ],
      "dataInicio": "2025-12-05T00:33:05-03:00",
      "dataFinalizacao": "2025-12-05T03:40:28.630Z",
      "resultado": "✅ Corrigido bug de drag-and-drop ao filtrar por milestone.\n✅ Implementada lógica robusta de inserção baseada no ID da task e na lista completa, ignorando o índice visual filtrado.\n✅ Adicionada atualização otimista de timeline e metadados no frontend.\n✅ Implementada escrita atômica (temp + rename) e lock de concorrência no backend para salvar tasks.json.\n✅ Adicionado rollback automático em caso de erro na persistência.\n\nArquivos modificados:\n- client/src/components/KanbanBoard.tsx\n- backend/server.js"
    },
    {
      "id": "t5020",
      "descricao": "Adicionar contador de tasks (filtradas) nas colunas do Kanban",
      "detalhes": "## O que fazer\n- Exibir um badge com o número de tasks VISÍVEIS no topo de cada coluna do Kanban (Backlog / To Do / Doing / Done).\n- Usar o array `tasks` recebido por `KanbanColumn` (já contém o resultado dos filtros aplicados em `KanbanBoard`) — não recalcular filtros no componente da coluna.\n- Contagem deve considerar apenas cards (cada task = 1), ignorando to-dos/sub-tarefas.\n- Usar o componente de UI existente `Badge` (shadcn/ui) para manter consistência visual e acessibilidade.\n- Badge deve estar ao lado do título da coluna (dentro do <h2> atual), com estilo pequeno/compacto e aria-label descrevendo o número (ex: \"3 tasks visíveis\").\n\n## Arquivos\n- Modificar: `client/src/components/KanbanColumn.tsx`\n  - Importar `Badge` de `@/components/ui/badge`.\n  - Calcular `const visibleCount = tasks.length;` e renderizar o Badge ao lado do título.\n  - Adicionar atributos acessíveis (`aria-live` ou `aria-label`) para atualizações dinâmicas.\n- Não é necessário alterar: `client/src/components/KanbanBoard.tsx` (já passa `filteredTasks` como `tasks` para cada `KanbanColumn`).\n- Usar estilos Tailwind já aplicados (seguir padrão de espaçamento dos títulos e botões). Se necessário, ajustar classes em `KanbanColumn.tsx` para espaçamento horizontal (`flex items-center gap-2` / `ml-2`).\n\n## Observações\n- Padrões do projeto: TypeScript + React + shadcn/ui + Tailwind v4. Siga o padrão de imports dos componentes shadcn (`@/components/ui/...`).\n- Garantir que o Badge mostre sempre um número inteiro (0 quando vazio).\n- A contagem deve reagir automaticamente a mudanças de filtros por milestone e à busca, porque `KanbanBoard` já envia as tasks filtradas.\n- Testes manuais recomendados: abrir a UI, aplicar filtro por milestone, usar busca, verificar atualização instantânea dos contadores; testar acessibilidade com leitor de tela (aria-label/aria-live).\n- Commit: mensagem sugerida \"feat(ui): adicionar contador de tasks filtradas nas colunas do Kanban\".",
      "todos": [
        {
          "id": "td50200524",
          "texto": "Importar `Badge` em client/src/components/KanbanColumn.tsx a partir de `@/components/ui/badge`",
          "concluido": true
        },
        {
          "id": "td50201284",
          "texto": "Calcular `const visibleCount = tasks.length` dentro de KanbanColumn e garantir é número inteiro (0 quando vazio)",
          "concluido": true
        },
        {
          "id": "td50205233",
          "texto": "Renderizar o `Badge` ao lado do título (linha do <h2>) com estilo compacto e espaçamento consistente (ex: gap-2 / ml-2)",
          "concluido": true
        },
        {
          "id": "td50206222",
          "texto": "Adicionar atributos de acessibilidade: `aria-label` descrevendo o número e `aria-live=\"polite\"` se apropriado para updates dinâmicos",
          "concluido": true
        },
        {
          "id": "td50205516",
          "texto": "Garantir que a contagem considere somente tasks (cada card = 1) e reaja aos filtros já aplicados pelo `KanbanBoard`",
          "concluido": true
        },
        {
          "id": "td50200799",
          "texto": "Fazer QA manual: aplicar filtros por milestone, pesquisar, verificar contadores em todas as colunas; adicionar screenshots/observações no commit",
          "concluido": true
        }
      ],
      "milestone": "m6021",
      "dataCriacao": "2025-12-08T02:55:25.000-03:00",
      "timeline": [
        {
          "coluna": "backlog",
          "timestamp": "2025-12-08T02:55:25.000-03:00"
        },
        {
          "coluna": "doing",
          "timestamp": "2025-12-08T03:11:20.291-03:00"
        }
      ],
      "dataInicio": "2025-12-08T03:11:20.291-03:00",
      "resultado": "✅ Implementação completa!\n\n## O que foi feito:\n\n1. **Importado Badge** - Adicionado `import { Badge } from \"@/components/ui/badge\"` em `client/src/components/KanbanColumn.tsx`\n\n2. **Calculado visibleCount** - Criada variável `const visibleCount = tasks.length` que conta automaticamente as tasks visíveis (já filtradas pelo KanbanBoard)\n\n3. **Renderizado Badge ao lado do título** - Badge inserido dentro do `<h2>` com:\n   - Estilo compacto: `text-xs font-normal`\n   - Espaçamento: `ml-1` e `gap-2`\n   - Variante: `secondary` para consistência visual\n\n4. **Acessibilidade implementada**:\n   - `aria-label` dinâmico com plural/singular correto\n   - `aria-live=\"polite\"` para anunciar mudanças aos leitores de tela\n\n5. **Reatividade automática** - O contador reage instantaneamente a:\n   - Filtros por milestone\n   - Busca por texto\n   - Adição/remoção de tasks\n   - Movimentação entre colunas\n\n## Resultado:\nCada coluna (Backlog, To Do, Doing, Done) agora exibe um badge compacto mostrando o número de tasks visíveis após aplicação de filtros. A contagem é sempre precisa e atualiza em tempo real."
    }
  ],
  "cloudSync": {
    "enabled": true,
    "slug": "pum9j69u",
    "url": "https://livekanban.dev/pum9j69u",
    "publishedAt": "2025-12-12T03:53:20.084Z",
    "token": "sk_P6ikiXgLS42BBuCaWvMKsQhk4RB9x5ez"
  }
}